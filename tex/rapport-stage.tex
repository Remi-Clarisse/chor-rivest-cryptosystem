\documentclass[a4paper, titlepage, 11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{amsmath, amsthm, amssymb, mathabx}
\usepackage{tikz}
\usepackage{algorithm, algorithmic}
\usepackage{array}
\usepackage{cite}
\usepackage{tikz}
\usepackage{hyperref}
\hypersetup{
     colorlinks   = true,
     citecolor    = magenta,
     linkcolor    = cyan,
     linktoc      = page
}
\usepackage[top=3cm, bottom=3cm, left=3cm , right=3cm]{geometry}

\newtheorem{theo}{Théorème}[section]
\newtheorem{lemm}[theo]{Lemme}
\newtheorem{prop}[theo]{Proposition}
\newtheorem{coro}[theo]{Corollaire}
\theoremstyle{definition}
\newtheorem{defi}[theo]{Définition}
\theoremstyle{remark}
\newtheorem{rema}[theo]{Remarque}
\newtheorem{exem}[theo]{Exemple}
\newtheorem{appl}[theo]{Application}
\newtheorem{heur}[theo]{Heuristique}


\def\N{\mathbb N}
\def\A{\mathbb A}
\def\Z{\mathbb Z}
\def\Q{\mathbb Q}
\def\R{\mathbb R}
\def\C{\mathbb C}
\def\K{\mathbb K}
\def\F{\mathbb F}
\def\O{\mathcal O}
\def\o{o}
\def\gf #1{\mathbb{F}_{#1}}
\def\frob{\operatorname{Frob}}
\def\card{\operatorname{Card}}
\def\car{\operatorname{car}}
\def\pgcd{\operatorname{pgcd}}
\def\ppcm{\operatorname{ppcm}}
\def\id{\operatorname{id}}
\def\aut{\operatorname{Aut}}
\def\hom{\operatorname{Hom}}
\def\isom{\operatorname{Isom}}
\def\gal{\operatorname{Gal}}
\def\mbf #1{\mathbf{#1}}
\def\NP{\mathbb{NP}}
\def\gen #1{\left\langle#1\right\rangle}
\def\ceil #1{\left\lceil#1\right\rceil}
\def\floor #1{\left\lfloor#1\right\rfloor}

\newcommand{\extension}[2]{{#1} / {#2}} % #1 grand corps et #2 petit corps

\floatname{algorithm}{Algorithme}
\renewcommand{\algorithmicrequire}{\textbf{Entrée :}}
\renewcommand{\algorithmicensure}{\textbf{Sortie :}}
\renewcommand{\algorithmicend}{\textbf{fin}}
\renewcommand{\algorithmicif}{\textbf{si}}
\renewcommand{\algorithmicthen}{\textbf{alors}}
\renewcommand{\algorithmicelse}{\textbf{sinon}}
\renewcommand{\algorithmicfor}{\textbf{pour}}
\renewcommand{\algorithmicforall}{\textbf{pour tout}}
\renewcommand{\algorithmicdo}{\textbf{faire}}
\renewcommand{\algorithmicwhile}{\textbf{tant que}}
\renewcommand{\algorithmicloop}{\textbf{boucle}}
\renewcommand{\algorithmicrepeat}{\textbf{repéter}}
\renewcommand{\algorithmicuntil}{\textbf{jusqu'à}}
\renewcommand{\algorithmicprint}{\textbf{afficher}}
\renewcommand{\algorithmicreturn}{\textbf{retourner}}
\renewcommand{\algorithmictrue}{\textbf{vrai}}
\renewcommand{\algorithmicfalse}{\textbf{faux}}

\title{\'Etude du cryptosystème de Chor-Rivest}
\author{Rémi {\sc Clarisse}}
\date{Mai-Août 2017}

\begin{document}
\thispagestyle{empty}
\centerline{\includegraphics[width=8cm,height=25mm]{logo-bordeaux.png} \hspace{2cm} \includegraphics[width=8cm,height=25mm]{logo-inria.png}}

\vspace{2cm}

\centerline{\large\bfseries Master 1 de Cryptologie et Sécurité Informatique}
\centerline{\large\bfseries \'Equipe-projet GRACE}
\centerline{\rule{5cm}{2pt}}
\centerline{\bfseries Stage estival 2017}


\begin{center}
\vspace{3cm}

{\Huge\bfseries Rapport de stage \\}
\vspace{0.15cm}\centerline{\rule{10cm}{0.5pt}}\vspace{0.15cm}
{\LARGE\bfseries \'Etude du cryptosystème de Chor-Rivest}
 \vspace{4cm}

{\large Rémi {\sc Clarisse}}

\vspace{6.5cm}

{\large Tuteurs: Daniel {\sc Augot} et Luca {\sc De Feo}}
\end{center}
\newpage
\thispagestyle{empty}
\section*{Introduction}

De mai à août 2017, j'ai intégré en tant que stagiaire l'équipe GRACE de Inria Saclay - Île-de-France. Sous la supervision de Daniel Augot, responsable de l'équipe, et Luca De Feo, j'ai étudié le cryptosystème \cite{chorRivest1988} présenté par Benny Chor et Ronald Rivest en 1984, ainsi que l'algorithme \cite{joux2013} qu'Antoine Joux à conçu en 2013 pour le calcul de logarithme discret dans un corps fini de petite caractéristique. Pour des raisons de limite temporelle, je n'ai pas vu l'algorithme quasi-polynomial \cite{barbulescu2013}, qui pourrait \textit{peut-être} mieux répondre à la problématique que nous nous posons.

Le cryptosystème de Chor-Rivest est un cryptosytème asymétrique qui base sa sécurité sur un problème de sac à dos. Cependant, pour produire la clé publique, il faut avoir recours à des calculs de logarithmes discrets dans un corps fini $\gf{p^h}$. C'est pour cela que Chor et Rivest incitent l'utilisateur à prendre des paramètres facilitant la résolution du problème du logarithme discret, en sélectionnant par exemple un exposant $h$ friable. C'est justement ce pré-requis qui à permis à Serge Vaudenay en 2000 de confectionner une cryptanalyse \cite{vaudenay2000}, qui lui fait arriver à la conclusion qu'il faut choisir un exposant $h$ premier.

Nous sommes donc au croisement de deux recommandations: l'une facilitant le calcul de logarithme pour fabriquer les clés et l'autre rendant le cryptosystème résistant à la meilleure cryptanalyse existante à ce jour. Il est clair qu'avoir un cryptosystème cassé est inutile. C'est pour cela que nous nous intéressons à l'algorithme de Joux, afin que le calcul des logarithmes ne soit plus un obstacle.

Le rapport est organisé comme suit: en section~\ref{sec:presInria}, nous présentons Inria, ainsi que l'équipe-projet GRACE. Les section~\ref{sec:cryptosysteme} et section~\ref{sec:cryptanalyse} exposent les travaux déjà effectués sur le cryptosysème de Chor-Rivest et la cryptanalyse de Vaudenay. La section~\ref{sec:DLPJoux} donne divers resultats sur le calcul de logarithmes discrets dans des corps finis et aborde le papier de Joux, dont nous déduirons, en section~\ref{sec:consequences}, des améliorations possibles pour le cryptosystème de Chor-Rivest.

\setcounter{tocdepth}{1}
\tableofcontents

\paragraph{GitHub.} Des fichiers comportant les divers algorithmes sont présents sur GitHub pour agrémenter la lecture du rapport. Il y a une implémentation élémentaire en \verb|C| de l'algorithme rho de Pollard \cite{pollard1978} dans un corps $\gf{p}$, où $p$ est un nombre premier inférieur à $2^{32}$, ainsi que d'autres fichiers en \verb|sage| implémentant le cryptosystème de Chor-Rivest \cite{chorRivest1988}, l'attaque de Serge Vaudenay \cite{vaudenay2000} et l'algorithme d'Antoine Joux \cite{joux2013}, exposés en section \ref{sec:cryptosysteme}, \ref{sec:cryptanalyse} et \ref{sec:DLPJoux} respectivement. Il est laissé au lecteur d'explorer le dépôt documenté.
\paragraph{web URL.}\url{https://github.com/Remi-Clarisse/chor-rivest-cryptosystem.git}

\newpage

\section{La présentation de Inria}\label{sec:presInria}

Inria (Institut National de Recherche en Informatique et en Automatique) emploie 2\;600 collaborateurs issus des meilleures universités mondiales, qui relèvent les défis des sciences informatiques et mathématiques. Inria est organisé en \og{}équipes-projets\fg{} qui rassemblent des chercheurs aux compétences complémentaires autour d’un projet scientifique focalisé. Ce modèle ouvert et agile lui permet d’explorer des voies originales avec ses partenaires industriels et académiques. Inria répond ainsi aux enjeux pluridisciplinaires et applicatifs de la transition numérique. À l'origine de nombreuses innovations créatrices de valeur et d'emploi, Inria transfère vers les entreprises (start-up, PME et grands groupes) ses résultats et ses compétences, dans des domaines tels que la santé, les transports, l'énergie, la communication, la sécurité et la protection de la vie privée, la ville intelligente, l’usine du futur\dots

\subsection{Centre Inria Saclay - Île-de-France}

À Paris-Saclay, Inria développe des recherches à fort impact sociétal pour inventer le monde de demain. Créé en 2008, le centre de recherche Inria Saclay - Île-de-France accueille 450 scientifiques et 100 membres des services d’appui à la recherche. Les scientifiques sont organisés en 31 équipes de recherche dont 26 sont communes avec des partenaires du plateau de Saclay. Le centre accueille également le Joint Lab Inria / Microsoft Research.

\textit{\og{}Le centre Inria Saclay - Île-de-France est un acteur essentiel de la recherche en sciences du numérique sur le plateau de Saclay. Il porte les valeurs et les projets qui font l’originalité d’Inria dans le paysage de la recherche: l’excellence scientifique, le transfert technologique, les partenariats pluridisciplinaires avec des établissements aux compétences complémentaires aux nôtres, afin de maximiser l’impact scientifique, économique et sociétal d’Inria.\fg{}} \\
--- Bertrand Braunschweig, directeur du centre Inria Saclay - Île-de-France.

\paragraph{Source.} \url{https://www.inria.fr/}

\subsection{L'équipe-projet GRACE}

%(Luca) Avant de présenter le système, tu devrais présenter ton stage: objectifs, outils, résultats.

\section{Le cryptosystème de Chor-Rivest}\label{sec:cryptosysteme}

Dans leur article~\cite{chorRivest1988} publié en 1988, Benny Chor et Ronald Rivest introduisent un nouveau cryptosystème de chiffrement à clé publique. Ils se sont inspirés du théorème de Bose-Chowla \cite{bose1962} pour créer un cryptosystème reposant sur un problème de sac à dos et résistant à l'attaque de Jeffrey Lagarias et Andrew Odlyzko \cite{lagarias1983}.

Avant de donner le théorème de Bose-Chowla, informons qu'ici, le \textit{poids} d'un vecteur d'entiers $(x_0, \dots, x_{p-1})$ est $|x_0| + \dots + |x_{p-1}|$, i.e. sa norme $L^1$.

\begin{theo}[Théorème de Bose-Chowla]
Soient $p$ un nombre premier et $h \geqslant 2$ un entier. Il existe une suite ${(a_i)}_{0\leqslant i \leqslant p-1}$ d'entiers telle que : \begin{enumerate}
\item pour tout $0 \leqslant i \leqslant p-1$, $$1 \leqslant a_i \leqslant p^h-1,$$
\item si $(x_0, \dots, x_{p-1})$ et $(y_0, \dots, y_{p-1})$ sont deux vecteurs distincts d'entiers naturels de poids inférieur à $h$, alors
$$\sum_{i=0}^{p-1} x_ia_i \neq \sum_{i=0}^{p-1} y_ia_i.$$
\end{enumerate}
\end{theo}

\begin{proof}
Dans l'extension de corps finis $\extension{\gf{p^h}}{\gf{p}}$, notons $\gf{p} = \{\alpha_0, \dots, \alpha_{p-1} \}$. Soit $t$ un élément de $\gf{p^h}$ algébrique de degré $h$. Soit $g$ un élément primitif de $\gf{p^h}$. Considérons l'ensemble des translatés de $t$ par un élément de $\gf{p}$, à savoir $\{ t + \alpha_i : \alpha_i \in \gf{p} \}$.

Soit $a_i := \log_g(t + \alpha_i)$, où $\alpha_i \in \gf{p}$, le logarithme de $t+\alpha_i$ en base $g$ dans $\gf{p^h}$. Alors les $a_i$ sont tous des entiers de l'intervalle $\ldbrack1, p^h -1\rdbrack$ et, montrons par l'absurde que, toutes les sommes de $h$ termes de la suite ${(a_i)}_{0\leqslant i \leqslant p-1}$ sont distinctes. 

Soient deux vecteurs d'entiers naturels $(x_0, \dots, x_{p-1})$ et $(y_0, \dots, y_{p-1})$ distincts et de poids au plus $h$ tels que :
$$\sum_{i=0}^{p-1}x_ia_i = \sum_{i=0}^{p-1}y_ia_i.$$
Il s'en suit l'égalité dans $\gf{p^h}$ : $g^{\sum x_ia_i} = g^{\sum y_ia_i}$, et donc :
$$\prod_{i=0}^{p-1} {\left({g^{a_i}}\right)}^{x_i} = \prod_{i=0}^{p-1} {\left({g^{a_i}}\right)}^{y_i}.$$
En utilisant l'égalité $g^{a_i} = t + \alpha_i$ et en ne considérant que les $x_i$ et $y_i$ non-nuls, nous obtenons :
$$(t+\beta_1)^{x_{i_1}}(t+\beta_2)^{x_{i_2}} \cdots (t+\beta_l)^{x_{i_l}} = (t+\gamma_1)^{y_{j_1}}(t+\gamma_2)^{y_{j_2}} \cdots (t+\gamma_m)^{y_{j_m}},$$
où $\{\beta_1, \dots, \beta_l \}$ et $\{ \gamma_1, \dots, \gamma_m\}$ sont deux sous-ensembles non-vides de $\gf{p}$ de cardinal au plus $h$. Les deux polynômes de part et d'autre de la dernière égalité, sont donc distincts, unitaires, de degré au plus $h$ et à coefficients dans $\gf{p}$. Ainsi, en faisant la différence de ces deux polynômes, nous obtenons que $t$ est racine d'un polynôme non-nul de degré au plus $h-1$ et dont les coefficients sont dans $\gf{p}$. Cela contredit le fait que $t$ est algébrique de degré $h$ sur $\gf{p}$.
\end{proof}

Cela permet de construire une instance du problème de sac à dos ne reposant pas sur une suite super-croissante, qui sont faciles à résoudre.

\subsection{Description}

Soient $p$ une puissance non-nulle de nombre premier et $h \geqslant 2$ un entier naturel. Considérons le corps fini à $p^h$ élément, noté $\gf{p^h}$. La représentation de $\gf{p^h}$ est supposée publique, i.e. il existe un polynôme $P(X)$ public de degré $h$ irréductible sur $\gf{p}$ et les éléments de $\gf{p^h}$ sont vus comme des polynômes modulo $P(X)$ :
$$\gf{p^h} \cong \frac{\gf{p}[X]}{(P(X))}.$$
Considérons aussi une numérotation publique $\alpha$ du sous-corps de base $\gf{p}$, i.e. $$\{\alpha_0,\dots, \alpha_{p-1}\} = \gf{p} \subset \gf{p^h}.$$

\paragraph{Génération des clés.} Les éléments de la clé privée consistent en :
\begin{enumerate}
\item un générateur $g$ du groupe cyclique $\gf{p^h}^\times$,
\item un élément $t \in \gf{p^h}$ algébrique de degré $h$ sur $\gf{p}$, dont on note $\mu(X) \in \gf{p}[X]$ le polynôme minimal,
\item une permutation $\sigma$ de l'ensemble $\{0, \dots, p-1\}$,
\item un entier $d$ tel que $0 \leqslant d \leqslant p^h-2$.
\end{enumerate}
La clé publique est alors composée des :
$$c_i := d + \log_g\left(t + \alpha_{\sigma(i)}\right) \pmod{p^h-1}, \qquad 0 \leqslant i \leqslant p-1.$$

\'Etant donné qu'il faut calculer des logarithmes discrets pour fabriquer la clé publique, les paramètres choisis doivent faciliter le calcul des ces logarithmes dans $\gf{p^h}$. Ainsi, Chor et Rivest suggèrent de prendre pour $p$ un entier premier petit, ou une puissance de nombre premier petite, et pour $h$ un entier friable, permettant l'utilisation de l'algorithme de Pohlig-Hellman \cite{pohligHellman1978}. En l’occurrence, ils ont proposé de se placer dans des corps tels que $\gf{197^{24}}$, $\gf{211^{24}}$, $\gf{243^{24}}$ et $\gf{256^{25}}$.

\paragraph{Espace des messages.}L'espace des messages est l'ensemble des chaînes de $p$ bits et de poids de Hamming égal à $h$. C'est-à-dire que le message à chiffrer doit être une chaîne de bits $m = [m_0\cdots m_{p-1}]$ telle que $m_0+\dots + m_{p-1} = h$. N'importe quel message peut être découpé en plusieurs messages de $p$ bits et de poids $h$ en suivant un algorithme d'encodage donné dans \cite[IV.B.]{chorRivest1988}.

\paragraph{Chiffrement.}L'espace des chiffrés est $\Z/(p^h-1)\Z$ et le chiffré d'un message $m$ est :
$$E(m) := \sum_{i=0}^{p-1} m_ic_i \pmod{p^h-1}.$$
\paragraph{Déchiffrement.}Pour déchiffrer, nous calculons :
$$G(t) := g^{E(m) - hd},$$
vu comme un polynôme en $t$ à coefficients dans $\gf{p}$ et de degré au plus $h-1$. Comme $g$ est primitif dans $\gf{p^h}$, i.e. l'ordre de $g$ est $p^h-1$, l'exposant $E(m) - hd$ est à déterminer modulo $p^h-1$ :

\begin{align*}
E(m) - hd &\equiv \left(\sum_{i=0}^{p-1} m_ic_i\right) - hd \pmod{p^h-1}, \\
&\equiv \left(\sum_{i=0}^{p-1} m_i\left(d + \log_g\left(t + \alpha_{\sigma(i)}\right)\right)\right) - hd \pmod{p^h-1}, \\
&\equiv \left(hd + \sum_{i=0}^{p-1} m_i\log_g\left(t + \alpha_{\sigma(i)}\right)\right) - hd \pmod{p^h-1}, \\
&\equiv  \sum_{i=0}^{p-1} m_i\log_g\left(t + \alpha_{\sigma(i)}\right) \pmod{p^h-1}. \\
\end{align*}
D'où, l'égalité dans $\gf{p^h}$ :
$$G(t) = g^{E(m) - hd} = \prod_{i=0}^{p-1} \left(t+\alpha_{\sigma(i)}\right)^{m_i} = \prod_{m_i = 1} \left(t+\alpha_{\sigma(i)}\right).$$
Cela donne l'expression de l'élément $G(t)$ dans la base $(1,t,t^2, \dots, t^{h-1})$ du $\gf{p}$-espace vectoriel $\gf{p^h}$, où $t = X \pmod{\mu(X)}$. Ainsi :
$$G(X) \equiv \prod_{m_i = 1} \left(X+\alpha_{\sigma(i)}\right) \pmod{\mu(X)}.$$
Il existe donc un polynôme $\lambda(X) \in \gf{p}[X]$ tel que : $$G(X) = \lambda(X) \mu(X) + \prod_{m_i = 1} \left(X+\alpha_{\sigma(i)}\right).$$
En raisonnant sur les degrés, et comme $\mu(X)$ et $\prod \left(X+\alpha_{\sigma(i)}\right)^{m_i}$ sont unitaires, nous déduisons  $\lambda(X) = -1$, dont il découle l'égalité de polynômes :
$$G(X) + \mu(X) = \prod_{m_i = 1} \left(X+\alpha_{\sigma(i)}\right).$$
Ainsi, la factorisation de $G(X)+\mu(X)$ permet de recouvrer le message $m$.

\subsection{Exemple}
Nous nous servons de \verb|sage| pour construire un exemple\footnote{Les lignes de commandes peuvent être copiées telles quelles, elles fonctionnent, mais il est fort probable que les clés ne soient pas les mêmes que dans cet exemple. Les valeurs de $p$ et $h$ peuvent d'ailleurs être changées !

Cet exemple est essentiellement ce qu'il y a dans le fichier \textit{chor-rivest-prime-number.sage}.} d'une instance du cryptosystème de Chor-Rivest. Prenons $p := 17$ et $h := 6$, ainsi $p^h = 24\;137\;569$.
\begin{verbatim}
sage: p = 17
sage: h = 6
sage: q = p ** h
\end{verbatim}
Demandons à \verb|sage| de construire $\gf{17^6}$ :
\begin{verbatim}
sage: K.<a> = FiniteField(q)
sage: P = a.minimal_polynomial()
\end{verbatim}
Le corps fini $\gf{17^6}$ construit est en l’occurrence :
$$\frac{\gf{17}[X]}{(P(X))}, \text{ où } P(X) := X^6 + 2X^4 + 10 X^2 +3X +3\in  \gf{17}[X].$$
Les commandes suivantes permettent d'obtenir une numérotation du sous-corps premier :
\begin{verbatim}
sage: alpha = [K(i) for i in range (p)]
sage: shuffle (alpha)
\end{verbatim}
La numérotation $\alpha$ donnée par \verb|sage| est ici :
$$(\alpha_0, \dots, \alpha_{16}) = (2, 12, 4, 1, 0, 10, 7, 8, 15, 16, 3, 5, 13, 9, 11, 6, 14)$$
\subsubsection{Génération des clés}
Nous souhaitons déterminer un élément primitif $g$ de $\gf{17^6}$ :
\begin{verbatim}
sage: while True :
sage:     g = K.random_element()
sage:     if g.multiplicative_order() == q - 1 :
sage:         break
\end{verbatim}
Notons $a = X \pmod{P(X)}$. L'élément primitif $g$ sélectionné est alors :
$$g := 2a^5 + 5a^4 + 14a^3 + 2a^2 + 10a + 16.$$
Ensuite, pour l'élément algébrique $t$ de degré $6$ sur $\gf{17}$ :
\begin{verbatim}
sage: while True :
sage:     t = K.random_element()
sage:     if t.minimal_polynomial().degree() == h :
sage:         break
sage: mu = t.minimal_polynomial()
\end{verbatim}
Ce code \verb|sage| donne :
$$t := 9a^5 + 16a^4 + 10a^3 + 3a^2 + 12a + 12,$$
de polynôme minimal :
$$\mu(X) := X^6 + 9X^5 + 8X^4 + 14X^3 + X^2 + 11X + 6\in\gf{17}[X].$$
La ligne de commande :
\begin{verbatim}
sage: s = Permutations([i for i in range (p)]).random_element()
\end{verbatim}
sélectionne une permutation $\sigma$ de l'ensemble $\{0, \dots, 16\}$ valant :
$$\sigma := (10, 6, 3, 9, 12, 1, 14, 15, 5, 16, 8, 11, 7, 2, 0, 4, 13).$$
Enfin : 
\begin{verbatim}
sage: d = randint (0, q - 2)
\end{verbatim}
assigne la valeur $1\;530\;545$ à l'entier $d$.

Nous avons fini de fabriquer la clé privée ! Reste à construire la clé publique :
\begin{verbatim}
sage: c = [mod (d + log (t + alpha[s[i]], g), q - 1)
                                              for i in range (p)]
\end{verbatim}
Cela donne :
$$\begin{array}{r c l c r c l c r c l}
c_0 &:=& 21\;667\;185, &&
c_1 &:=& 3\;210\;064, &&
c_2 &:=& 6\;070\;281, \\
c_3 &:=& 3\;093\;929, &&
c_4 &:=& 19\;945\;987, &&
c_5 &:=& 294\;610, \\
c_6 &:=& 4\;230\;580, &&
c_7 &:=& 18\;951\;770, &&
c_8 &:=& 7\;364\;695, \\
c_9 &:=& 23\;348\;812, &&
c_{10} &:=& 7\;918\;908, &&
c_{11} &:=& 3\;562\;855, \\
c_{12} &:=& 6\;735\;636, &&
c_{13} &:=& 13\;077\;876, &&
c_{14} &:=& 11\;303\;489, \\
c_{15} &:=& 22\;106\;426, &&
c_{16} &:=& 18\;193\;975.
\end{array}$$


\subsubsection{Chiffrement d'un message}
Maintenant, donnons nous un message à chiffrer de longueur $17$ et de poids $6$ :
\begin{verbatim}
sage: m = [1 for i in range (h)] + [0 for i in range (p - h)]
sage: shuffle (m)
\end{verbatim}
$$m := [m_0\cdots m_{16}] = [00100101100100100].$$
Chiffrons $m$ :
\begin{verbatim}
sage: e = mod (sum ([m[i]*c[i] for i in range (p)]), q-1)
\end{verbatim}
$$E(m) := 23\;410\;132.$$

\subsubsection{Déchiffrement du message}
Nous souhaitons écrire $g^{E(m) - hd}$ comme un polynôme en $t$. Or \verb|sage| nous donne $g^{E(m) - hd}$ comme polynôme en $a$ : $$g^{E(m) - hd} = a^5 + 11a^3 + 9a^2 + 15a + 1.$$
Pour parvenir à exprimer $g$ comme nous le souhaitons, il faut effectuer un changement de base du $\gf{17}$-espace vectoriel $\gf{17^6}$ : passer de la base $\mathcal{A} := (1, a, a^2, \dots, a^{h-1})$ à la base $\mathcal{T} := (1, t, t^2, \dots, t^{h-1})$.
La matrice de passage facile à calculer est celle qui passe de la base $\mathcal{T}$ à la base $\mathcal{A}$ : il suffit d'écrire dans \verb|sage| les différentes puissances de $t$, et \verb|sage| les exprime en fonction des puissances de $a$ :
\begin{verbatim}
sage: V = K.vector_space()
sage: M = Matrix (GF(p),
                      [V(t ** i) for i in range (h)]).transpose()
\end{verbatim}
Voici cette matrice :
$$M := \left[\begin{array}{cccccc}
1 & 12 & 7 & 11 & 14 & 0 \\
0 & 12 & 9 & 12 & 6 & 12 \\
0 & 3 & 8 & 3 & 7 & 12 \\
0 & 10 & 0 & 15 & 15 & 14 \\
0 & 16 & 4 & 0 & 13 & 3 \\
0 & 9 & 15 & 10 & 5 & 6 \\
\end{array}\right]$$
Celle qui nous intéresse est son inverse, la matrice de passage de la base $\mathcal{A}$ à la base $\mathcal{T}$ :
\begin{verbatim}
sage: Minv = M.inverse()
\end{verbatim}
$$M^{-1} = \left[\begin{array}{cccccc}
1 & 5 & 10 & 12 & 15 & 11 \\
0 & 8 & 8 & 0 & 11 & 5 \\
0 & 13 & 13 & 9 & 5 & 1 \\
0 & 9 & 10 & 3 & 11 & 9 \\
0 & 12 & 6 & 2 & 16 & 8 \\
0 & 7 & 16 & 2 & 13 & 11 \\
\end{array}\right]$$
Comme $g^{E(m) - hd}$ vaut dans la base $\mathcal{A}$ le vecteur $(1, 15, 9, 11, 0, 1)$, il est facile d'obtenir l'égalité:
$$g^{E(m) - hd} = 10t^5 + 9t^4 + 12t^3 + 4t^2 + 10t + 3.$$
grâce à la commande:
\begin{verbatim}
sage: G = list (Minv * V(g ** (e - h * d))
\end{verbatim}
Notons $G(X) := 10X^5 + 9X^4 + 12X^3 + 4X^2 + 10X + 3 \in \gf{17}[X]$, ainsi le message est recouvré en factorisant le polynôme:
$$G(X) + \mu(X) = X^6 + 2X^5 + 9X^3 + 5X^2 + 4X + 9,$$
ce que nous faisons :
\begin{verbatim}
sage: A.<X> = PolynomialRing (GF(p))
sage: Q = A(G) + A(mu)
sage: Q.factor()
\end{verbatim}
$$G(X) + \mu(X) = (X + 1)(X + 2)(X + 5)(X + 6)(X + 10)(X + 12).$$
Nous pouvons alors déterminer les $\alpha_i$ utilisés et nous savons ainsi que le bit $m_{\sigma^{-1}(i)}$ du message $m$ est à $1$ :
\begin{verbatim}
sage: beta = [p - Q.roots()[i][0] for i in range (h)]
sage: sInv = [s.index(i) for i in range (p)]
sage: message = [0 for i in range (p)]
sage: for k in beta :
sage:     message[sInv [alpha.index(k)]] = 1
\end{verbatim}
Par exemple, pour le cas $\alpha_{\sigma(i)} = 1$: nous cherchons d'abord l'indice $j$ tel que $\alpha_j = 1$, à savoir $j = 3$. Puis nous déterminons son antécédent par la permutation : $\sigma^{-1}(3) = 2$. Et on constate en effet $m_2 = 1$.

\section{La cryptanalyse de Serge Vaudenay}\label{sec:cryptanalyse}

Nous présentons ici la cryptanalyse de Serge Vaudenay \cite{vaudenay2000}, publiée en 2000. Elle s'appuie sur la forte friabilité de $h$, i.e. sur l'existence de nombreux sous-corps de $\gf{p^h}$. Cette attaque ne requiert pas d'émission de chiffrés, elle se base seulement sur la connaissance de la clé publique. Elle exploite une faiblesse du cryptosystème, à savoir que par design, il existe plusieurs clés privées qui produisent la même clé publique.

Ici, nous donnons l'attaque pour $p$ un nombre premier, bien qu'elle soit adaptable pour le cas où $p$ est une puissance d'un nombre premier. En outre, nous exposons l'attaque à rebours, à savoir que nous partons du cas où quelques éléments de la clé privée sont connus et, au fur et à mesure, nous les retirons en regardant comment les construire.

\subsection{Notion de clés privées équivalentes}

Dans le cryptosystème de Chor-Rivest, nous choisissons la clé privée de façon aléatoire puis, à partir de celle-ci, nous calculons la clé publique. Le système repose sur la difficulté de trouver une clé secrète à partir de la clé publique. Cependant, nous remarquons qu'il y a plusieurs clés privées \textit{équivalentes}, à savoir qu'il existe plusieurs jeux de clés privées qui donnent la même clé publique.

Affinons. Nous pouvons remplacer $t$ et $g$ par leur puissance $p$-ième, la clé publique reste inchangée car :
$$\log_{g^p}\left(t^p + \alpha_{\sigma(i)}\right) = \frac{1}{p}\log_{g}\left(\left(t + \alpha_{\sigma(i)}\right)^p\right) = \log_{g}\left(t + \alpha_{\sigma(i)}\right).$$
Nous pouvons aussi remplacer $(t, \alpha_{\sigma})$ par $(t + v, \alpha_{\sigma} - v)$, pour tout $v \in \gf{p}$. Et enfin, nous pouvons remplacer $(t,d,\alpha_\sigma)$ par $(ut, d - \log_g(u), u\alpha_\sigma)$, quel que soit $u \in \gf{p}^\times$.
Cela donne donc, en général, au moins $hp(p-1)$ clés privées équivalentes.

Il s'agit alors de déterminer une de ces clés.


\begin{defi}
Deux clés privées sont dites \textit{équivalentes} si elles produisent la même clé publique. En d'autres termes, deux clés privées $(g,t,\sigma,d)$ et $(g',t',\pi ,d')$ sont équivalentes, si on a l'égalité de suites :
$$\left(d + \log_g(t + \alpha_{\sigma(i)})\right)_{0\leqslant i \leqslant p-1} = \left(d' + \log_{g'}(t' + \alpha_{\pi(i)})\right)_{0\leqslant i \leqslant p-1}.$$
\end{defi}

Pour passer d'une clé privée à une clé privée équivalente, il existe une transformation intéressante sur la permutation $\sigma$ qui permet de choisir arbitrairement deux images pour deux antécédents fixés -- ici, on prend les images de $0$ et $1$ :

\begin{prop}\label{prop:permutation}
Soient $i$ et $j$ deux entiers distincts et $\sigma$ une permutation d'une clé privée. Alors, il existe $\pi$ une permutation d'une clé privée équivalente, telle que, $$\pi(0) = i \qquad \text{et}\qquad \pi(1) = j.$$
\end{prop}

\begin{proof}
Posons :
$$\quad u = \frac{\alpha_i - \alpha_j}{\alpha_{\sigma(0)}- \alpha_{\sigma(1)}} \in \gf{p}^\times \quad \text{ et } \quad v =  \frac{\alpha_j\alpha_{\sigma(0)} - \alpha_i\alpha_{\sigma(1)}}{\alpha_{\sigma(0)}- \alpha_{\sigma(1)}} \in \gf{p}.$$
Il faut alors définir la permutation $\pi$ par
$$\alpha_{\pi(i)} = u\alpha_{\sigma(i)} + v,\qquad \forall i : 0\leqslant i \leqslant p-1.$$
\end{proof}

\paragraph{Notation.} Le discours qui suit porte sur la recherche de clés privées équivalentes. Souvent, elles sont exprimées en fonction de la clé privée possédée par le destinataire légitime. On note en lettre grasse la clé privée d'origine $(\mbf{g}, \mbf{t}, \sigma, \mbf{d})$ et en police ordinaire une clé privée équivalente $(g, t, \pi, d)$ -- la permutation d'une clé équivalente est notée $\pi$.

\begin{rema}
Aussi, nous faisons (parfois implicitement) le raccourci de << trouver \underline{une} clé privée équivalente >> à << trouver \underline{la} clé privée équivalente >>. Les algorithmes présentés donnent quasi-tous une liste d'éléments possibles en sortie, alors qu'un seul nous suffit.
\end{rema}

\subsection{Cléf de voûte de l'attaque}

Serge Vaudenay construit -- il s'est appuyé sur ses travaux précédents -- un polynôme bien particulier, qui est la pierre angulaire de son attaque contre le cryptosystème.

\begin{prop}\label{prop:vaudenay}
Pour tout facteur $r$ de $h$, il existe un générateur $\mbf g_{p^r}$ du groupe multiplicatif du sous-corps $\gf{p^r}$ de $\gf{p^h}$ et un polynôme $Q(X) \in \gf{p^r}[X]$ de degré $h/r$, tel que $-\mbf t$ en est une racine, et tel que pour tout $0\leqslant i \leqslant p-1$ :
$$Q\left(\alpha_{\sigma(i)}\right) = (\mbf g_{p^r})^{c_i}.$$
\end{prop}

\begin{proof}
Soit
$$Q(X) = (\mbf g_{p^r})^{\mbf d} \prod_{i=0}^{h/r-1} \left(X+\mbf t^{p^{ri}}\right),
\quad \text{ où } \mbf g_{p^r} := \prod_{i=0}^{h/r-1} \mbf g^{p^{ri}}.$$
$\mbf g_{p^r}$ est la norme de $\mbf g$ considéré dans l'extension de corps $\extension{\gf{p^h}}{\gf{p^r}}$, ainsi nous avons l'égalité $(\mbf g_{p^r})^{p^r} = \mbf g_{p^r}$ et $\mbf g_{p^r}$ est générateur de $\gf{p^r}^\times$ car $\mbf g$ est primitif dans $\gf{p^h}$. Nous remarquons que $Q\left(X^{p^r}\right) = Q(X)^{p^r}$, ce qui prouve que $Q(X) \in \gf{p^r}[X]$. En effet :
\begin{align*}
Q\left(X\right)^{p^r} &= (\mbf g_{p^r})^{\mbf dp^r} \prod_{i=0}^{h/r-1} \left(X+\mbf t^{p^{ri}}\right)^{p^r}, \\
&= (\mbf g_{p^r})^{\mbf d} \prod_{i=0}^{h/r-1} \left(X^{p^r} + \mbf t^{p^{ri}p^r}\right), \\
&= (\mbf g_{p^r})^{\mbf d} \prod_{i=1}^{h/r} \left(X^{p^r} + \mbf t^{p^{ri}}\right), \\
&= Q\left(X^{p^r}\right), \\
\end{align*}
car $\mbf t^{p^{r(h/r)}} = \mbf t^{p^h} = \mbf t = \mbf t^{p^0}$. Cela montre au passage que $Q(-\mbf t) = 0$. Aussi, $Q(X)$ est visiblement un polynôme de degré $h/r$. Et enfin, pour $0\leqslant j \leqslant p-1$, calculons $(\mbf g_{p^r})^{c_j}$ :
\begin{align*}
(\mbf g_{p^r})^{c_j} &= \left(\prod_{i=0}^{h/r-1} \mbf g^{p^{ri}}\right)^{c_j},\\
&= \prod_{i=0}^{h/r-1} \left(\mbf g^{c_j}\right)^{p^{ri}}, \\
&= \prod_{i=0}^{h/r-1} \mbf g^{\mbf dp^{ri}}\left(\alpha_{\sigma(j)} + \mbf t\right)^{p^{ri}},\\
&= (\mbf g_{p^r})^{\mbf d} \prod_{i=0}^{h/r-1} \left(\alpha_{\sigma(j)} + \mbf t^{p^{ri}}\right),\\
&= Q\left(\alpha_{\sigma(j)}\right). \\
\end{align*}
Cela achève la démonstration de la proposition.
\end{proof}

Comme $h/r$ est assez petit, il est peu probable qu'il existe d'autres solutions $(\mbf g_{p^r}, Q(X))$, et $\mbf g_{p^r}$ est donc essentiellement unique. Soulignons la particularité de ce polynôme $Q(X)$, il est à coefficients dans $\gf{p^r}$, il est de degré $h/r$ et nous connaissons ses images sur tout $\gf{p}$ : il peut donc être interpolé sur un petit sous-ensemble de $\gf{p}$.

\paragraph{Notation.} Pour $r$ divisant $h$ et $\omega$ élément de $\gf{p^h}$, notons $$\omega_{p^r} := \omega^{(p^h-1)/(p^r-1)} = \omega^{1+p^r+p^{2r}+p^{3r}+\cdots+p^{h-r}},$$
la norme de $\omega$ considéré dans l'extension de corps $\extension{\gf{p^h}}{\gf{p^r}}$.

\subsection{Comment trouver $t$ sachant $\mbf g_{p^r}$ et $\sigma$}

Supposons connus la norme $\mbf g_{p^r}$ et la permutation $\sigma$. Nous pouvons alors interpoler le polynôme $Q(X)$ de la proposition~\ref{prop:vaudenay}, avec $h/r +1$ paires ${(\alpha_{\sigma(i)}, (\mbf g_{p^r})^{c_i})}$. Cela donne un polynôme de degré $h/r$ dont les racines sont les conjugués de $-\mbf t$.  Par équivalence entre clés privées, nous pouvons sélectionner n'importe quelle racine de $Q(X)$. Cet algorithme est l'objet de l'Algorithme~\ref{algo:premiereAttaqueVaudenay}.

Nous résolvons l'attaque en calculant $g$ et $d$ -- d'une clé équivalente donc -- grâce à l'attaque de Oded Goldreich exposée dans \cite[VII.A.3]{chorRivest1988}. Une version simplifiée sera utilisée plus loin, c'est pour cela qu'elle est volontairement omise ici.

\paragraph{Notation.} Pour $j$ tel que $0\leqslant j \leqslant h/r$, on note $\mathcal L_j(X)$ le \textit{polynôme interpolateur de Lagrange} :
$$\mathcal L_j(X) := \prod_{\substack{0\leqslant k\leqslant h/r \\ k \neq j}}\frac{X-\alpha_{\sigma(k)}}{\alpha_{\sigma(j)}-\alpha_{\sigma(k)}}.$$

\begin{algorithm}[h]
\caption{Algorithme implémentant l'attaque sachant $\mbf g_{p^r}$ et $\sigma$}
\label{algo:premiereAttaqueVaudenay}
\begin{algorithmic}[1]
\REQUIRE $\gf{p^h}$, $(c_0,\dots, c_{p-1})$, $\sigma$, $r$ divisant $h$ et $\mbf g_{p^r}$
\ENSURE $\mbf t, \mbf t^{p^r}, \mbf t^{p^{2r}}, \dots, \mbf t^{p^{h - r}}$
\STATE{$Q(X) \in \gf{p^r}[X]$ : initialiser $Q(X) \gets 0$}
\FOR{$j$ allant de $0$ à $h/r$}
	\STATE{$Q(X) \gets Q(X) + (\mbf g_{p^r})^{c_j} \mathcal L_j(X)$}
\ENDFOR
\RETURN{$[-x \in \gf{p^h}$ pour $x$ racine du polynôme $Q(X) ]$}
\end{algorithmic}
\end{algorithm}

\paragraph{Choix des points d'interpolation.}

Dans son papier, Serge Vaudenay interpole le polynôme $Q(X)$ de la proposition~\ref{prop:vaudenay} sur un ensemble quelconque de $h/r+1$ éléments de $\gf{p}$. À savoir, il choisit des indices $i_0, i_1, \dots, i_{h/r}$ pris entre $0$ et $p-1$, deux à deux distincts ; et interpole le polynôme en les éléments $\alpha_{i_j}$ pour $j$ tel que $0 \leqslant j \leqslant h/r$.

Pour simplifier le propos, et surtout pour rendre plus lisible l'écriture, nous faisons le choix ici de prendre $i_j = j$, pour tout $0 \leqslant j \leqslant h/r$. C'est ce qui a été fait dans l'algorithme~\ref{algo:premiereAttaqueVaudenay}.

\subsection{Comment trouver $\pi$ sachant $\mbf g_{p^r}$: l'approche directe}

Supposons connu l'élément $\mbf g_{p^r}$. Par la proposition~\ref{prop:vaudenay}, nous pouvons interpoler le polynôme $Q(X)$ en les $\alpha_{\sigma(j)}$, pour $0 \leqslant j \leqslant h/r$ :
$$ Q(X) = \sum_{j=0}^{h/r} Q\left(\alpha_{\sigma(j)}\right) \mathcal L_j(X) = \sum_{j=0}^{h/r} (\mbf g_{p^r})^{c_{j}} \mathcal L_j(X),$$
ce qui donne pour tout $i$ tel que $0\leqslant i \leqslant p-1$ :
\begin{equation}\label{eqn:interpolation}
(\mbf g_{p^r})^{c_i} = \sum_{j=0}^{h/r} (\mbf g_{p^r})^{c_{j}} \mathcal L_j(\alpha_{\sigma(i)}).
\end{equation}

Par équivalence entre clés privées et grâce à la proposition~\ref{prop:permutation}, nous pouvons choisir arbitrairement les images $\pi(0)$ et $\pi(1)$, où $\pi$ est la permutation d'une clé équivalente à celle contenant $\sigma$. L'algorithme naïf \ref{algo:naifgpr} trouve la permutation $\pi$ en cherchant exhaustivement les valeurs $\pi(j)$ pour $2\leqslant j \leqslant h/r$, en vérifiant avec l'équation~(\ref{eqn:interpolation}) que la permutation est consistante.

\begin{algorithm}[h]
\caption{Algorithme pour trouver $\pi$ sachant $\mbf g_{p^r}$}
\label{algo:naifgpr}
\begin{algorithmic}[1]
\REQUIRE $\gf{p^h}$, $(c_0,\dots, c_{p-1})$, $r$ divisant $h$ et $\mbf g_{p^r}$
\ENSURE une permutation $\pi$ d'une clé privée équivalente
\STATE{choisir arbitrairement $\pi(0)$ et $\pi(1)$ distincts dans $\{0, \dots, p-1\}$}
\FORALL{$\pi(2), \pi(3), \dots, \pi({h/r})$ distincts deux à deux} \label{boucle:algoNaifgprBoucle}
	\STATE{$S \gets \left\{\pi(0), \pi(1), \pi(2), \dots, \pi({h/r})\right\}$}
	\FORALL{$\ell \not\in S$} \label{boucle:algoNaifgprBoucle2}
		\STATE{calculer le membre de droite $\mathbf{res}$ de l'équation~(\ref{eqn:interpolation}) avec $\alpha_\ell$ au lieu de $\alpha_{\pi(i)}$}
		\IF{il existe $i$ tel que $\mathbf{res} = (\mbf g_{p^r})^{c_i}$ et $\pi(i)$ n'est pas définie}
			\STATE{$\pi(i) \gets \ell$}
			\STATE{$S \gets S \cup \{\pi(i)\}$}
		\ELSE
			\STATE{continuer la boucle ligne~\ref{boucle:algoNaifgprBoucle}}
		\ENDIF
	\ENDFOR
	\RETURN{$\pi$}
\ENDFOR
\end{algorithmic}
\end{algorithm}

La complexité de cet algorithme~\ref{algo:naifgpr} est grossièrement $\O((h/r)^2p^{h/r}/(h/r)!)$ opérations dans $\gf{p}$ : la boucle à la ligne~\ref{boucle:algoNaifgprBoucle2} fait $\O(p)$ itérations, chacune avec une complexité $\O((h/r)^2)$, et nous avons besoin\footnote{Si $n\geqslant k \geqslant 1$, alors $\binom{n}{k} \leqslant \frac{n^k}{k!}$.} de $\O(p^{h/r}/(h/r)!)$ itérations de cette boucle.

Maintenant que nous avons obtenu la permutation $\pi$, nous souhaitons résoudre l'attaque. C'est ici qu'intervient l'attaque de Goldreich simplifiée susmentionnée. Pour comprendre son fonctionnement, il faut d'abord exprimer $t$, de la clé privée équivalente que nous sommes en train de fabriquer, en fonction de $\mbf t$. 

Par la proposition~\ref{prop:permutation}, la permutation $\pi$ donnée par l'algorithme~\ref{algo:naifgpr} est telle qu'il existe $u \in \gf{p}^\times$ et $v \in \gf{p}$ vérifiant :
$$\alpha_{\pi(i)} = u \alpha_{\sigma(i)} + v, \qquad \forall i : 0 \leqslant i \leqslant p-1.$$
En exprimant le polynôme $Q(X)$ faisant intervenir la permutation $\pi$, noté $Q_\pi(X)$, par rapport au polynôme $Q(X)$ faisant intervenir la permutation $\sigma$, noté $Q_\sigma(X)$, nous obtenons :
\begin{align*}
Q_\pi(X) &= \sum_{j=0}^{h/r} (\mbf g_{p^r})^{c_{j}} \prod_{\substack{0\leqslant k\leqslant h/r \\ k \neq j}}\frac{X-\alpha_{\pi(k)}}{\alpha_{\pi(j)}-\alpha_{\pi(k)}}, \\
&= \sum_{j=0}^{h/r} (\mbf g_{p^r})^{c_{j}} \prod_{\substack{0\leqslant k\leqslant h/r \\ k \neq j}}\frac{X-u\alpha_{\sigma(k)} - v}{u\alpha_{\sigma(j)}-u\alpha_{\sigma(k)}}, \\
&= \sum_{j=0}^{h/r} (\mbf g_{p^r})^{c_{j}} \prod_{\substack{0\leqslant k\leqslant h/r \\ k \neq j}}\frac{u^{-1}X - u^{-1}v-\alpha_{\sigma(k)}}{\alpha_{\sigma(j)}-\alpha_{\sigma(k)}}, \\
&= Q_\sigma(u^{-1}(X -v)). \\
\end{align*}
Si $-\omega$ est racine du polynôme $Q_\pi(X)$, alors $-u^{-1}(\omega +v)$ est racine du polynôme $Q_\sigma(X)$, donc si on fait tourner l'algorithme~\ref{algo:premiereAttaqueVaudenay} avec la permutation $\pi$, les valeurs renvoyées sont :
$$u \mbf t -v,\quad u \mbf t^{p^r} -v,\quad u \mbf t^{p^{2r}} -v,\quad \dots,\quad u \mbf t^{p^{h - r}} -v.$$

Finissons l'attaque: choisissons un générateur arbitraire $\gamma$ de $\gf{p^h}^\times$ et un $j$ tel que $0 \leqslant j < h/r$, à savoir on choisit n'importe quel élément retourné par l'algorithme~\ref{algo:premiereAttaqueVaudenay}. Posons $$b_i := \log_{\gamma}\left(u \mbf t^{p^{jr}} -v+\alpha_{\pi(i)}\right).$$
Notons $L := \log_{\gamma}(\mbf g^{p^{jr}})$, de sorte que $\mbf g^{p^{jr}}=\gamma^L$. Alors pour tout $0 \leqslant i \leqslant p-1$ :
\begin{align*}
b_i - b_0 &= \log_{\gamma}\left(\frac{u \mbf t^{p^{jr}} -v + \alpha_{\pi(i)}}{u \mbf t^{p^{jr}} -v + \alpha_{\pi(0)}}\right), \\
&= \log_{\gamma}\left(\frac{u \mbf t^{p^{jr}} -v + u \alpha_{\sigma(i)}+v}{u \mbf t^{p^{jr}} -v + u \alpha_{\sigma(0)}+v}\right),\\
&= \log_{\gamma}\left(\frac{u \mbf t^{p^{jr}} + u \alpha_{\sigma(i)}}{u \mbf t^{p^{jr}} + u \alpha_{\sigma(0)}}\right),\\
&= L\log_{\mbf g^{p^{jr}}}\left(\frac{\mbf t^{p^{jr}} + \alpha_{\sigma(i)}}{\mbf t^{p^{jr}} + \alpha_{\sigma(0)}}\right),\\
&= L(c_i - c_0). \\
\end{align*}
Par conséquence, s'il existe un $i$ tel que $(c_i - c_0)$ est inversible modulo $p^h - 1$, nous retrouvons : 
$$L = (b_i - b_0)(c_i - c_0)^{-1} \pmod{p^h-1},$$
ce qui permet de déterminer $g$ et $d$.
L'attaque de Goldreich simplifiée est dépeinte par l'algorithme~\ref{algo:attaqueGoldreichsimplifiee}.

\begin{algorithm}[h]
\caption{Attaque de Goldreich simplifiée}
\label{algo:attaqueGoldreichsimplifiee}
\begin{algorithmic}[1]
\REQUIRE $\gf{p^h}$, $(c_0,\dots, c_{p-1})$, $t$ et $\pi$
\ENSURE $g$ et $d$
\STATE{choisir $\gamma$ un élément primitif arbitraire de $\gf{p^h}$}
\STATE{calculer les $b_i := \log_{\gamma}(t+\alpha_{\pi(i)})$}
\STATE{$B \gets [ b_i - b_0$ pour $i$ allant de $0$ à $p-1 ] $}
\STATE{$C \gets [ c_i - c_0$ pour $i$ allant de $0$ à $p-1 ] $}
\FOR{$i$ allant de $0$ à $p-1$}
	\IF{$\pgcd(C[i], p^h-1) = 1$}
		\STATE{$L \gets C[i]^{-1}B[i] \pmod{p^h-1}$}
		\STATE{$\mathcal{C} \gets \{L\cdot C[j] \pmod{p^h-1}$ pour $j$ allant de $0$ à $p-1 \}$}
		\STATE{$\mathcal{B} \gets \{B[j] \pmod{p^h-1}$ pour $j$ allant de $0$ à $p-1 \}$}
		\IF[\textit{égalité en tant qu'ensembles}]{$\mathcal{C} = \mathcal{B}$}
			\STATE{$g \gets \gamma^L$}
			\STATE{$d \gets c_0 - \log_g(t+\alpha_{\pi(0)}) \pmod{p^h -2}$}
			\RETURN{$g$ et $d$}
		\ENDIF
	\ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

Si en entrée de l'algorithme~\ref{algo:attaqueGoldreichsimplifiee}, le $t$ donné est $u \mbf t^{p^{jr}} -v$, la clé équivalente construite est : $$(\mbf g^{p^{jr}}, u \mbf t^{p^{jr}} -v, \pi, \mbf d - \log_{\mbf g^{p^{jr}}}(u)).$$

\subsection{Comment trouver $\pi$ sachant $\mbf g_{p^r}$: l'approche maligne}

Quand $r$ est suffisamment grand, il existe un meilleur algorithme pour trouver $\pi$. En effet, si $r \geqslant h/r$, alors la famille $\left((\mbf g_{p^r})^{c_{j}} - (\mbf g_{p^r})^{c_{0}} \right)_{1\leqslant j \leqslant h/r}$ est libre. 
Cela signifie que les coefficients dans l'équation (\ref{eqn:interpolation}) sont les seuls coefficients dans $\gf{p}$ de l'écriture du vecteur $(\mbf g_{p^r})^{c_{i}} - (\mbf g_{p^r})^{c_{0}}$, pour $1\leqslant i \leqslant p-1$, comme combinaison linéaire des vecteurs : $$(\mbf g_{p^r})^{c_{1}} - (\mbf g_{p^r})^{c_{0}},\quad \dots,\quad (\mbf g_{p^r})^{c_{{h/r}}} - (\mbf g_{p^r})^{c_{0}}.$$
Cela est résumé dans la proposition suivante :

\begin{prop}Pour tout $i$ tel que $0\leqslant i \leqslant p-1$ :
\begin{equation}\label{eqn:combLineaire}
(\mbf g_{p^r})^{c_i} - (\mbf g_{p^r})^{c_{0}} = \sum_{j=1}^{h/r} \left((\mbf g_{p^r})^{c_{j}} - (\mbf g_{p^r})^{c_{0}} \right)\mathcal L_j(\alpha_{\sigma(i)}).
\end{equation}
\end{prop}

\begin{proof}
Soit $i$ tel que $0 \leqslant i \leqslant {h/r}$ :
$$(\mbf g_{p^r})^{c_i} - (\mbf g_{p^r})^{c_{0}} = \sum_{j=1}^{h/r} \left((\mbf g_{p^r})^{c_{j}} - (\mbf g_{p^r})^{c_{0}} \right)\mathcal L_j(\alpha_{\sigma(i)}).$$
Ainsi, nous avons l'égalité de polynôme :
$$Q(X) - (\mbf g_{p^r})^{c_{0}} = \sum_{j=1}^{h/r} \left((\mbf g_{p^r})^{c_{j}} - (\mbf g_{p^r})^{c_{0}} \right)\mathcal L_j(X),$$
car les deux polynômes sont de degré $h/r$ et sont égaux sur un ensemble de $h/r + 1$ éléments : d'où l'égalité lorsque les polynômes sont évalués en les $\alpha_{\sigma(i)}$, pour $0\leqslant i \leqslant p-1$.\end{proof}

Notons $a_j^i$ le coefficient de $(\mbf g_{p^r})^{c_{{j}}} - (\mbf g_{p^r})^{c_{0}}$ pour $(\mbf g_{p^r})^{c_{i}} - (\mbf g_{p^r})^{c_{0}}$, où $i , j\geqslant 1$. Alors, par l'équation (\ref{eqn:combLineaire}), nous avons, si $a_1^i \neq 0$ :
\begin{align*}
\frac{a_2^i}{a_1^i} &= \left(\prod_{\substack{0\leqslant k\leqslant h/r \\ k \neq 2}} \frac{\alpha_{\sigma(i)}-\alpha_{\sigma(k)}}{\alpha_{\sigma(2)}-\alpha_{\sigma(k)}} \right)\left(\prod_{\substack{0\leqslant k'\leqslant h/r \\ k' \neq 1}} \frac{\alpha_{\sigma(i)}-\alpha_{\sigma({k'})}}{\alpha_{\sigma(1)}-\alpha_{\sigma({k'})}} \right)^{-1}, \\
&= \left(\prod_{\substack{0\leqslant k\leqslant h/r \\ k \neq 2}} \frac{\alpha_{\sigma(i)}-\alpha_{\sigma(k)}}{\alpha_{\sigma(2)}-\alpha_{\sigma(k)}} \right)\left(\prod_{\substack{0\leqslant k' \leqslant h/r \\ k' \neq 1}} \frac{\alpha_{\sigma(1)}-\alpha_{\sigma({k'})}}{\alpha_{\sigma(i)}-\alpha_{\sigma({k'})}} \right), \\
&= \left(\prod_{\substack{0\leqslant k, k'\leqslant h/r \\ k \neq 2, k' \neq 1}} \frac{\alpha_{\sigma(1)}-\alpha_{\sigma({k'})}}{\alpha_{\sigma(2)}-\alpha_{\sigma(k)}} \right) \left(\prod_{\substack{0\leqslant k, k'\leqslant h/r \\ k \neq 2, k' \neq 1}} \frac{\alpha_{\sigma(i)}-\alpha_{\sigma(k)}}{\alpha_{\sigma(i)}-\alpha_{\sigma({k'})}} \right), \\
&= \left(\prod_{\substack{0\leqslant k, k'\leqslant h/r \\ k \neq 2, k' \neq 1}} \frac{\alpha_{\sigma(1)}-\alpha_{\sigma({k'})}}{\alpha_{\sigma(2)}-\alpha_{\sigma(k)}} \right) \left(\frac{\alpha_{\sigma(i)}-\alpha_{\sigma(1)}}{\alpha_{\sigma(i)}-\alpha_{\sigma(2)}} \right). \\
\end{align*}
Ainsi, il existe $\nu$ dans $\gf{p}$, indépendant de $i$, tel que :
\begin{equation}\label{eqn:coeff}
\frac{a_2^i}{a_1^i} = \nu \frac{\alpha_{\pi(i)}-\alpha_{\pi(1)}}{\alpha_{\pi(i)}-\alpha_{\pi(2)}}\quad\Leftrightarrow\quad
\alpha_{\pi(i)} = \frac{a_2^i\alpha_{\pi(2)}-\nu a_1^i\alpha_{\pi(1)}}{a_2^i-\nu a_1^i}.
\end{equation}
En passant toutes les valeurs de $\nu$ en revue, nous pouvons obtenir $\pi(i)$ de l'équation (\ref{eqn:coeff}). Cependant, cela ne permet pas de déterminer $\pi(0)$ et $\pi(j)$ pour $3 \leqslant j \leqslant h/r$. Il reste alors à les chercher de manière exhaustive. Cette remarque donne naissance à l'algorithme~\ref{algo:gpr}.

\begin{algorithm}[h]
\caption{Algorithme pour trouver $\pi$ sachant $\mbf g_{p^r}$ lorsque $r\geqslant \sqrt h$}
\label{algo:gpr}
\begin{algorithmic}[1]
\REQUIRE $\gf{p^h}$, $(c_0,\dots, c_{p-1})$, $r$ divisant $h$ tel que $r\geqslant \sqrt h$ et $\mbf g_{p^r}$
\ENSURE une permutation $\pi$ d'une clé privée équivalente
\STATE{pré-calculer la matrice de changement de bases de la ``base classique'' vers la ``base'' $\left((\mbf g_{p^r})^{c_{j}} - (\mbf g_{p^r})^{c_{0}} \right)_{0\leqslant j \leqslant h/r}$}
\STATE{choisir arbitrairement $\pi(1)$ et $\pi(2)$ distincts dans $\{0, \dots, p-1\}$}
\FORALL{$\nu$ dans $\gf{p}$}\label{boucle:algogpr}
	\FOR{$i$ tel que $0\leqslant i\leqslant p-1$ et $i \neq 0, 1, \dots, h/r$}\label{boucle:algogpr2}
		\STATE{écrire $(\mbf g_{p^r})^{c_{i}} - (\mbf g_{p^r})^{c_{0}}$ dans la ``base'' $\left((\mbf g_{p^r})^{c_{j}} - (\mbf g_{p^r})^{c_{0}} \right)_{1\leqslant j \leqslant h/r}$}
		\STATE{récupérer les coefficients $a_1^i$ et $a_2^i$}
		\STATE{trouver la valeur de $\pi(i)$ grâce à l'équation (\ref{eqn:coeff})}
	\ENDFOR
	\STATE{essayer de compléter $\pi$ en cherchant exhaustivement $\pi(0)$ et $\pi(j)$ pour $3 \leqslant j \leqslant h/r$}\label{state:algogpr}
	\IF{$\pi$ vérifie les équations (\ref{eqn:interpolation})}\label{cond:algogpr}
		\RETURN{$\pi$}
	\ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

La complexité de l'algorithme~\ref{algo:gpr} est $\O\left((p+h/r)^3\right)$. Détaillons. Le calcul de la matrice se fait en $\O\left((h/r)^3\right)$ opérations. La boucle ligne~\ref{boucle:algogpr2} effectue $\O(p)$ itérations d'une complexité de $\O(h/r)$ chacune, la recherche ligne~\ref{state:algogpr} se fait en $\O(h/r)$ et la condition ligne~\ref{cond:algogpr} se vérifie en $\O\left((h/r)^2\right)$. Tout cela est dans la boucle ligne~\ref{boucle:algogpr} qui se répète $\O(p)$ fois. Ainsi, on atteint la complexité :
$$\O\left(\left(\frac{h}{r}\right)^3 + p\left( p\frac{h}{r} + \frac{h}{r} + \left(\frac{h}{r}\right)^2\right)\right).$$

\subsection{Comment trouver $\mbf g_{p^r}$}

Les équations, quel que soit $i$ tel que $0\leqslant i \leqslant p-1$,
$$(\mbf g_{p^r})^{c_i} - (\mbf g_{p^r})^{c_{0}} = \sum_{j=1}^{h/r} \left((\mbf g_{p^r})^{c_{j}} - (\mbf g_{p^r})^{c_{0}} \right) \mathcal L_j(\alpha_{\sigma(i)}),$$
signifient que tous les $(\mbf g_{p^r})^{c_i}$ sont en fait dans un même sous-espace affine de dimension $h/r$ du $\gf{p}$-espace vectoriel $\gf{p^r}$. Donc si on suppose que $h/r + 1 \leqslant r$, à savoir $r \geqslant \sqrt{h + 1/4} + 1/2$, on peut donner un test facile pour $\mbf g_{p^r}$ :

\begin{prop}
S'il existe un facteur $r$ de $h$ de sorte que $r \geqslant \sqrt{h + 1/4} + 1/2$, alors tous les $\mbf g_{p^r}^{c_i}$ sont sur le même sous-espace affine de dimension $h/r$ de $\gf{p^r}$ lorsque celui-ci est considéré comme un espace affine de dimension $r$ sur $\gf{p}$.
\end{prop}

L'existence d'un tel $r$ peut être considérée comme un mauvais prérequis, cependant vu que les paramètres du cryptosystème de Chor-Rivest ont été choisis de sorte que le problème du logarithme discret soit facile à résoudre, nous savons déjà que $h$ à plusieurs facteurs, et il est donc fort probable que cette hypothèse sur $r$ soit satisfaite. En fait, les seuls $h$ sans de tels facteurs sont les nombres premiers et les carrés de nombres premiers. Le vrai problème est que $r$ ne doit pas être trop grand, sinon la recherche d'un $\mbf g_{p^r}$  devient fastidieuse.

Nous pouvons écrire l'algorithme \ref{algo:testgpr} qui vérifie si un candidat pour $\mbf g_{p^r}$ est bon : l'algorithme vérifie simplement si les $(\mbf g_{p^r})^{c_i}$ sont sur un même espace affine de dimension $h/r$. La condition ligne~\ref{cond:algoTestgpr} se vérifie en $\O(h^3/r)$ opérations dans $\gf{p}$. Comme il y a $\phi(p^r-1)/r$ candidats, nous pouvons chercher exhaustivement un $\mbf g_{p^r}$ avec une complexité de $\O(h^3p^r/r^2)$.

\begin{algorithm}[h]
\caption{Algorithme pour trouver $\mbf g_{p^r}$ lorsque $r\geqslant \sqrt{h + 1/4} + 1/2$}
\label{algo:testgpr}
\begin{algorithmic}[1]
\REQUIRE $\gf{p^h}$, $(c_0,\dots, c_{p-1})$ et $r$ divisant $h$ tel que $r\geqslant \sqrt{h + 1/4} + 1/2$
\ENSURE un élément $\mbf g_{p^r}$
\FORALL{$\zeta \in \gf{p^h}$ générateur de $\gf{p^r}^\times$} \label{boucle:algoTestgpr}
	\FORALL{$i$ allant de $h/r + 1$ à $p-1$}
		\IF{$\zeta^{c_{i}}$ n'appartient pas au sous-espace affine engendré par $(\zeta^{c_{0}}, \dots, \zeta^{c_{{h/r}}})$}\label{cond:algoTestgpr}
			\STATE{continuer la boucle ligne~\ref{boucle:algoTestgpr}}
		\ENDIF
	\ENDFOR
	\RETURN{$\zeta$}
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsection{Comment trouver $\mbf g_{p^r}$ en s'aidant des $c_i$}

En 1991, Hendrik Lenstra \cite{lenstra1991} soupçonnait qu'inclure tous les $c_i$ dans la clé publique était dangereux pour la sécurité du système. Et en effet, Serge Vaudenay a amélioré la recherche précédente en utilisant la connaissance de tous les $c_i$.

Avant de voir comment il a procédé, voici un fait dont nous allons nous servir :

\begin{prop}\label{prop:faitCool}
Soit $Q(X)$ un polynôme de $\gf{p^r}[X]$ de degré $d$ et soit $e$ un entier tel que $1 \leqslant e < (p-1)/d$. Alors : $$\sum_{a \in \gf{p}} Q(a)^e = 0.$$
\end{prop}
Le lemme qui suit permet de démontrer cette proposition.

\begin{lemm}
Soit $k$ un entier tel que $1 \leqslant k < p-1$. Alors
$$\sum_{a\in\gf{p}} a^k = 0.$$
Ainsi, si $P(X) \in \gf{p^r}[X]$ est de degré inférieur à $p-1$, alors : $$\sum_{a\in\gf{p}} P(a) = 0.$$
\end{lemm}

\begin{proof}[Démonstration de la proposition]
Comme $Q(X) \in \gf{p^r}[X]$ est de degré $d$ et que $e$ est tel que $1\leqslant e < (p-1)/d$, le polynôme $Q(X)^e$ est de degré inférieur à $p-1$. Le lemme précédent conclut :
$$\sum_{a\in\gf{p}} Q(a)^e = 0.$$
\end{proof}

Cela nous donne un critère particulièrement intéressant pour $\mbf g_{p^r}$ :
\begin{prop}
Pour tout $1 \leqslant e < (p-1)r/h$ :
$$\sum_{i=0}^{p-1} (\mbf g_{p^r})^{ec_i} = 0.$$
\end{prop}
\begin{proof}
Considérons le polynôme $Q(X)\in\gf{p^r}[X]$ de la proposition~\ref{prop:vaudenay} : le polynôme $Q(X)$ est de degré $h/r$, à coefficients dans $\gf{p^r}$ et tel que, pour tout $0 \leqslant i \leqslant p-1$ :
$$Q\left(\alpha_{\sigma(i)}\right) = (\mbf g_{p^r})^{c_i}.$$
Ainsi par la proposition~\ref{prop:faitCool}, pour tout $1 \leqslant e < (p-1)r/h$ :
$$\sum_{a\in\gf{p}} Q(a)^e = \sum_{i=0}^{p-1} Q\left(\alpha_{\sigma(i)}\right)^e = 0,$$
d'où l'égalité souhaitée :
$$\sum_{i=0}^{p-1} (\mbf g_{p^r})^{ec_i} = 0.$$
\end{proof}
\noindent Cela donne une façon plus simple, par rapport à la recherche exhaustive, de sélectionner tous les candidats pour $\mbf g_{p^r}$. Son principal avantage est qu'elle fonctionne dans n'importe quel sous-corps. Par exemple, on peut considérer $r=1$ et trouver les seuls $\mbf g_p$ tels que pour tout $1 \leqslant e < (p-1)/h$ :
$$\sum_{i=0}^{p-1} (\mbf g_p)^{ec_i} = 0.$$
La complexité moyenne pour vérifier un candidat est $\O(p)$ $\gf{p}$-opérations, et il est peu probable qu'un mauvais candidat ne soit pas détecté par le cas $e = 1$. Ainsi, nous pouvons recouvrer $\mbf g_p$ en $\O(p^2)$ opérations élémentaires.

Malheureusement, le $\mbf g_{p^r}$ ne peut pas être utilisé efficacement quand $r$ est trop petit. Toutefois, si on a calculé des $\mbf g_{p^r}$ dans des petits sous-corps, on peut s'aider de ceux-ci pour calculer un $\mbf g_{p^r}$ dans un plus grand sous-corps. En fait, notre objectif est de calculer $\mbf g_{p^r}$ avec $r$ tel que $r \geqslant h/r + 1$.

Considérons le problème du calcul de $\mbf g_{p^r}$ lorsque les facteurs $r_1,\dots,r_k$  de $r$ sont connus, et les $\mbf g_{p^{r_i}}$ pour $1 \leqslant i \leqslant k$, sont connus. Comme $\mbf g_{p^{r_i}} = (\mbf g_{p^r})^{1+p^{r_i}+p^{2r_i}+\cdots+p^{r-r_i}}$, nous avons
\begin{equation}\label{eqn:loggpr}
\log(\mbf g_{p^r}) = \frac{\log(\mbf g_{p^{r_i}})}{1+p^{r_i}+p^{2r_i}+p^{3r_i}+\cdots+p^{r-r_i}} \pmod{p^{r_i}-1},
\end{equation}
où la base des logarithmes est n'importe quel élément primitif $\gamma$ fixé dans le corps $\gf{p^r}$. La connaissance de tous les $\mbf g_{p^{r_i}}$ donne donc la connaissance de $\log(\mbf g_{p^r})$ modulo
$$\ell := \ppcm \left\{p^{r_1} - 1, p^{r_2}-1, \dots, p^{r_k} -1\right\}.$$
Nous avons donc besoin seulement de $(p^r-1)/\ell$ essais pour recouvrer $\mbf g_{p^r}$.
Cela permet d'écrire l'algorithme~\ref{algo:gprFromgpri}, recouvrant $\mbf g_{p^r}$ à partir des $\mbf g_{p^{r_i}}$.

\begin{algorithm}[h]
\caption{Algorithme pour récupérer $\mbf g_{p^r}$ à partir des $\mbf g_{p^{r_i}}$}
\label{algo:gprFromgpri}
\begin{algorithmic}[1]
\REQUIRE $\gf{p^h}$, $(c_0,\dots, c_{p-1})$, $r$ divisant $h$, ${\{r_i\}}_{1\leqslant i\leqslant k}$ diviseurs de $r$ et $\mbf g_{p^{r_i}}$
\ENSURE l'ensemble des $\mbf g_{p^r}$ possibles
\STATE{choisir $\gamma$ un élément primitif de $\gf{p^r}$}
\FORALL{$i$ allant de $1$ à $k$}
	\STATE{résoudre l'équation (\ref{eqn:loggpr}) : $$x_i = \frac{\log(\mbf g_{p^{r_i}})}{1+p^{r_i}+p^{2r_i}+p^{3r_i}+\cdots+p^{r-r_i}} \pmod{p^{r_i}-1}$$}
\ENDFOR
\STATE{$\ell \gets \ppcm \left\{p^{r_1} - 1, p^{r_2}-1, \dots, p^{r_k} -1\right\}$}
\STATE{résoudre $x \equiv x_i \pmod{p^{r_i}-1}$, pour $1 \leqslant i \leqslant k$ et où $x$ est unique modulo $\ell$ (CRT)}
\FOR{$y$ allant de $0$ à $(p^r-1)/\ell - 1$}\label{boucle:algogprFromgpri}
	\FOR{$e$ allant de $1$ à $(p-1)r/h - 1$}
		\IF{$\sum_{i=0}^{p-1} \gamma^{ec_i(x+\ell y)} \neq 0$}
			\STATE{continuer la boucle ligne~\ref{boucle:algogprFromgpri}}
		\ENDIF
	\ENDFOR
	\STATE{ajouter $\gamma^{x+\ell y}$ à la liste des $\mbf  g_{p^r}$ possibles}
\ENDFOR
\end{algorithmic}
\end{algorithm}

Chaque boucle de la ligne~\ref{boucle:algogprFromgpri} de l'algorithme~\ref{algo:gprFromgpri} demande en moyenne $\O(p^2r)$ opérations dans $\gf{p}$.

\subsection{Attaque de Serge Vaudenay}

Pour l'attaque, on s'intéresse aux sous-corps de $\gf{p^r}$.

\begin{defi}
Soit $G$ un graphe orienté acyclique (DAG pour \textit{directed acyclic graph}) étiqueté enraciné satisfaisant aux conditions: \begin{enumerate}
\item la racine est étiquetée par un sous-corps de $\gf{p^r}$,
\item le sommet sans arc sortant est étiqueté $\gf{p^r}$,
\item pour chaque arête $u \rightarrow v$ de $G$, l'étiquette $L(u)$ de $u$ est un sous-corps maximal (au sens de l'inclusion) de l'étiquette $L(v)$ de $v$ et est une extension du corps $\gf{p}$.
\end{enumerate}
On dit que $G$ est un \textit{DAG $p$-factorisant} de $\gf{p^r}$.
\end{defi}

\begin{exem}
Soit $p$ un nombre premier. Plaçons nous dans le corps $\gf{p^{24}}$, i.e. $h := 24$. L'attaque que nous échafaudons préconise de prendre $r = 6$ comme diviseur de $24$. Soit $G$ le DAG $p$-factorisant de $\gf{p^6}$ suivant :
\begin{figure}[h]
\begin{center}
\begin{tikzpicture}
\coordinate (F) at (0,0) ;
\coordinate (F2) at (-1.5,1.5) ;
\coordinate (F6) at (0,3) ;
\coordinate (F3) at (1.5,1.5) ;
\draw (F) node[below]{$\gf{p}$} node{$\bullet$} ;
\draw (F2) node[left]{$\gf{p^2}$} node{$\bullet$} ;
\draw (F6) node[above]{$\gf{p^6}$} node{$\bullet$} ;
\draw (F3) node[right]{$\gf{p^3}$} node{$\bullet$} ;
\draw[thick, ->, >= latex] (F) -- (F2) ;
\draw[thick, ->, >= latex] (F) -- (F3) ;
\draw[thick, ->, >= latex] (F2) -- (F6) ;
\draw[thick, ->, >= latex] (F3) -- (F6) ;
\end{tikzpicture}
\end{center}
\end{figure}
\end{exem}

\begin{defi}
\`A une extension $\gf{p^r}$ et $G$ son DAG $p$-factorisant, on associe :
$$C(G) := \sum_{v} \frac{\#L(v) -1}{\ppcm\{\#L(w)-1 \mid v \leftarrow w\}},$$
où on prend pour convention : $\ppcm(\emptyset) = 1$.
\end{defi}

\begin{exem}
Reprenons l'exemple précédent :
$$C(G) = \frac{p^6 - 1}{\ppcm(p^2-1, p^3-1)} + \frac{p^3-1}{p-1} + \frac{p^2}{p-1} + p-1.$$
Pour $p = 197$, cela donne $C(G) = 78\;014$.
\end{exem}

Nous pouvons définir un algorithme pour calculer $\mbf g_{p^r}$ avec pour complexité $\O(pr^2C(G))$, où $G$ est un DAG $p$-factorisant de $\gf{p^r}$. Donc, nous pouvons casser le cryptosystème de Chor-Rivest avec comme paramètre $h$ ni un nombre premier, ni un carré de nombre premier, avec une complexité de
$$\O\left(\min_{\substack{r \text{ divisant } h \\ r^2 \geqslant h}} \; \min_{\substack{G \text{ est un DAG}\\p\text{-factorisant} \\ \text{ de } \gf{p^r}}} \;
p^2rC(G)\right).$$
L'algorithme~\ref{algo:attaqueGeneral} illustre l'attaque complète de Serge Vaudenay.

\begin{algorithm}[h]
\caption{Attaque de Vaudenay}
\label{algo:attaqueGeneral}
\begin{algorithmic}[1]
\REQUIRE $\gf{p^h}$ et $(c_0,\dots, c_{p-1})$
\ENSURE une clé secrète équivalente
\STATE{pour le plus petit facteur $r$ de $h$ tel que $r \geqslant \sqrt{h + 1/4} + 1/2$, trouver $G$ un DAG $p$-factorisant minimisant $C(G)$}
\FORALL{$s$ sommet de $G$, tel que pour tout $s \leftarrow s_i$, $s_i$ a été visité,}
	\STATE{l'algorithme~\ref{algo:gprFromgpri} avec $\gf{p^r}=L(s)$ et $\gf{p^{r_i}} = L(s_i)$}
\ENDFOR
\STATE{$\pi \gets$ appliquer l'algorithme~\ref{algo:gpr} à $\mbf g_{p^r}$}
\STATE{$t \gets$ appliquer l'algorithme~\ref{algo:premiereAttaqueVaudenay} à $\mbf g_{p^r}$ et $\pi$}
\STATE{$g, d \gets$ appliquer l'algorithme~\ref{algo:attaqueGoldreichsimplifiee} à $t$ et $\pi$}
\RETURN{$(g,t,\pi,d)$}
\end{algorithmic}
\end{algorithm}

\subsection{Conclusion}

Serge Vaudenay a décrit une attaque du cryptosystème, lorsque $h$ admet un facteur $r$ tel que $r \geqslant \sqrt{h + 1/4} + 1/2$, ayant pour complexité $\O(h^3p^r/r^2)$.

L'attaque a été implémentée\footnote{Consulter le fichier \textit{vaudenay-attack.sage}} en \verb|sage|, bien que les résultats ne soient pas aussi bons que ceux de Serge Vaudenay : 1 heure et demie en moyenne contre 15 minutes, pour les corps $\gf{197^{24}}$ et $\gf{211^{24}}$.

Les préconisations de Serge Vaudenay pour réparer le cryptosystème de Chor-Rivest sont les suivantes : \begin{itemize}
\item choisir un corps fini $\gf{p^h}$ avec $p$ et $h$ tous les deux premiers,
\item ne pas divulguer tous les $c_i$ dans la clé publique.
\end{itemize}

\section{Le calcul de logarithmes discrets selon Antoine Joux}\label{sec:DLPJoux}

%(Luca) Explique pourquoi tu t'intéresses à ça, quel est le rapport avec la section précédente.

Dans son article \cite{joux2013} de 2013, Antoine Joux conçoit un algorithme permettant un calcul rapide de logarithme discret dans un corps fini de petite caractéristique. En imitant la thèse \cite{pierrot2016} de Cécile Pierrot, soutenue en 2016, nous faisons un historique des différents algorithmes dont s'est inspiré Antoine Joux, et nous donnons un algorithme aidant à comprendre ce qu'est la \textit{méthode du calcul d'indice}.

Nous allons donc passer en revue les algorithmes de Hellman-Reyneri et de Coppersmith, ainsi que le crible de corps de fonctions et la descente special-$\mathfrak{q}$, avant de décortiquer l'article \cite{joux2013} d'Antoine Joux. Mais d’abord, donnons quelques notions liminaires et le squelette de la méthode de calcul d’indice.

\subsection{Préliminaires}

Soient $p$ un nombre premier, $q$ une puissance non-nulle de $p$ et $k$ un entier naturel non-nul. On souhaite dans la suite résoudre le problème du logarithme discret dans $\gf{q^k}$, un corps fini à $q^k$ éléments.

On adopte la notation suivante pour donner la \textit{complexité d'un algorithme} :
$$L_{q^k}(\alpha, c) := \exp\left({(c+\o(1))(\log Q)^\alpha(\log\log Q)^{1 - \alpha}}\right),$$
où $0 \leqslant \alpha\leqslant 1$ et $c > 0$. Lorsque $\alpha = 0$, l'algorithme est dit \textit{polynomial}, si $0 < \alpha < 1$ alors l'algorithme est dit \textit{sous-exponentiel}, et enfin quand $\alpha = 1$, l'algorithme est dit \textit{exponentiel}. Notons aussi que la constante $c$ est souvent omise, la notation devenant simplement $L_{q^k}(\alpha)$.

La notion de \textit{petite, moyenne et grande caractéristique} est définie grâce à la notation précédente. À savoir, on commence par écrire $p = L_{p^n}(\ell,c)$ avec $0\leqslant\ell\leqslant 1$ et $c$ une constante proche de $1$. Si $\ell < 1/3$, on parle de petite caractéristique, si $1/3 < \ell < 2/3$, de moyenne caractéristique, et de grande caractéristique si $\ell > 2/3$.

\begin{defi}
Un polynôme $P(X) \in \gf{q}[X]$ est dit \textit{$d$-friable} s'il se factorise en produit de polynômes de $\gf{q}[X]$ de degré au plus $d$.
\end{defi}

Selon un résultat de Daniel Panario, Xavier Gourdon et Philippe Flajolet \cite{PGF98}, une estimation de la probabilité qu'un polynôme aléatoire de degré inférieur à $n$ soit $d$-friable est :
$${(n/d)}^{-n/d + \o(1)},$$
pour certaines valeurs de $n$ et $d$ non détaillées ici.

Dans un corps fini, le logarithme discret de $h \in \gf{q^k}$ en base $g \in \gf{q^k}$, où $g$ est primitif, est l'entier $a$, déterminé modulo l'ordre de $g$, tel que $h = g^a$. Concrètement, on s'est donné une représentation du corps fini $\gf{q^k}$, à savoir un polynôme irréductible de degré $k$, noté $J_k(X) \in \gf{q}[X]$. Et les éléments de $\gf{q^k}$ sont alors vus comme des polynômes modulo $J_k(X)$ :
$$\gf{q^k} \cong \frac{\gf{q}[X]}{(J_k(X))}.$$

\subsubsection{Description de la méthode du calcul d'indice}
La plupart des algorithmes de calcul de logarithmes discrets commencent par la recherche d'une \textit{autre représentation du corps $\gf{q^k}$}. Pour cela, ils sélectionnent un polynôme irréductible de degré $k$, notons le $I_k(X) \in \gf{q}[X]$. Le changement de représentation se fait de la façon suivante : soit $\alpha$ une racine du polynôme $I_k(X)$ et considérons $J_k(X)$ comme un polynôme à coefficients dans $\gf{q^k} \cong \gf{q}[\alpha]$. Ainsi $J_k(X) \in \gf{q}[\alpha][X]$ est scindé, et on peut exprimer toutes ses racines comme des polynômes en $\alpha$. Choisissons l'une d'entre elles au hasard et notons la $\beta$. Il est possible d'écrire $\beta = f(\alpha)$, où $f(X) \in \gf{q}[X]$. Dans le problème initial, $g$ et $h$ sont donnés comme des polynômes en $\beta$, disons $G(\beta)$ et $H(\beta)$, où $G(X)$ et $H(X)$ sont à coefficients dans $\gf{q}$. Dans la nouvelle représentation, il suffit de trouver le logarithme discret de $H(f(\alpha))$ en base $G(f(\alpha))$.

Ensuite, il faut déterminer un ensemble de $\gf{q^k}^\times$, que l'on nomme \textit{base de friabilité}, dont les éléments sont considérés comme ``petit''. Souvent, on fixe $d$ un entier assez petit, et les éléments de la base de friabilité sont ceux de la forme $F(\alpha)$, où $F(X)\in\gf{q}[X]$ est un polynôme de degré au plus $d$.

\begin{rema}
Une fois de plus, on se permet de faire l'amalgame entre deux objets : à savoir entre un \textit{élément du corps} appartenant à la base de friabilité et le \textit{polynôme} ayant servi à le représenter. Par exemple, si $h = H(\alpha)\in\gf{q^k}$ appartient à la base de friabilité, on pourra dire indistinctement que $h$  appartient à la base de friabilité ou bien que $H(X)$ appartient à la base de friabilité.
\end{rema}

Vient après la \textit{phase de collecte de relations} ou \textit{phase de crible}, à savoir, si la base de friabilité utilisée est $\{g_i : i \in I\}$, nous nous intéressons à des relations de la forme :
$$\prod_{i\in I} {g_i}^{u_i} = \prod_{i\in I} {g_i}^{v_i},$$
les $u_i$ et les $v_i$ étant définis modulo $q^k-1$. En termes de logarithmes discrets, cela donne :
$$\sum_{i\in I} u_i \log_gg_i = \sum_{i\in I} v_i \log_gg_i \pmod{q^k-1}.$$
La collecte s’arrête lorsque nous avons suffisamment d'équations pour résoudre le système linéaire associé, sachant que les inconnues sont les $\log_gg_i$ pour  $i\in I$.

Il s'en suit la résolution dudit système linéaire donné par les équations précédentes, appelée \textit{phase d'algèbre linéaire}. Nous ne nous épanchons pas ici sur les méthodes de résolutions, il faut juste savoir que le système produit est creux et que donc la complexité de cette phase est en général quadratique. Le lecteur intéressé pourra lire entre autre les papiers de Don Coppersmith, Andrew Odlyzko, et Richard Schroeppel \cite{coppersmith1986} et de Douglas Wiedemann \cite{wiedemann1986}.

Enfin, comme nous cherchons à déterminer le logarithme d'un élément arbitraire du corps, on passe à la \textit{phase de logarithme individuel}. L'essence de l'idée est ici d'exprimer l'élément arbitraire en fonction des éléments de la base de friabilité, pour en déduire son logarithme.

En résumé, un algorithme implémentant la méthode du calcul d'indice peut se diviser en quatre étapes : \begin{enumerate}
\item le changement de représentation du corps et le choix de la base de friabilité,
\item la phase de collecte de relations entre les éléments de la base de friabilité,
\item la phase d'algèbre linéaire pour connaître chaque logarithme des éléments de la base de friabilité,
\item la phase de logarithme individuel qui permet de d'obtenir le logarithme de n’importe quel élément du corps.
\end{enumerate}

\subsubsection{Heuristique de la méthode du calcul d'indice}

Les algorithmes par calcul d'indice reposent sur l'idée de décomposer des éléments comme produits d'éléments considérés comme ``petits''. Les éléments qui peuvent se factoriser de cette manière sont dits friables. Un problème essentiel pour l'analyse de ces algorithmes consiste à estimer la probabilité d'obtenir de tels éléments friables. Dans de nombreux cas, nous procédons heuristiquement en supposant que les éléments créés se comportent comme des éléments aléatoires de même taille. Bien qu'inélégante, car non prouvée, cette heuristique a permis d'obtenir de nombreux progrès algorithmiques.

Autant que faire se peut, nous mettrons en exergue le(s) heuristique(s) employé(s) par chaque méthode ou algorithme.

\subsection{Algorithme de Hellman-Reyneri en $L_{q^k}(1/2)$}

Choisissons $g$ un générateur du groupe multiplicatif $\gf{q^k}^\times$ et un entier $d$ tel que $1 < d < k$. L'algorithme de Martin Hellman et Justin Reyneri \cite{hellman1982} commence par sélectionner arbitrairement un polynôme $I_k(X) \in \gf{q}[X]$ unitaire irréductible de degré $k$, afin de représenter $\gf{q^k}$ comme $\gf{q}[\alpha]$, où $\alpha$ est une racine fixée de $I_k(X)$.

Remarquons ensuite que pour $r \in \ldbrack 0, q^k - 2 \rdbrack$ choisi aléatoirement de façon uniforme, $g^r$ est aussi un élément choisi aléatoirement de façon uniforme de $\gf{q^k}^\times$. Cet élément peut être représenté comme un polynôme $G_r(X) \in \gf{q}[X]$ de degré au plus $k-1$. Si $G_r(X)$ est $d$-friable, nous écrivons :
$$g^r = \beta \prod_{i=1}^{t} F_i(\alpha)^{e_i},$$
où les $F_i(X)\in \gf{q}[X]$ sont des polynômes irréductibles unitaires de degré au plus $d$ apparaissant dans la factorisation de $G_r(X)$ et $\beta$ est le coefficient dominant du polynôme $G_r(X)$. En prenant les logarithmes discrets, nous obtenons :
\begin{equation}\label{eqn:hellman-reyneri}
r = \log_g(\beta) + \sum_{i=1}^t e_i\log_g\big(F_i(\alpha)\big) \pmod{q^k - 1}.
\end{equation}

En faisant varier $r$, on obtient d'autres équations ($\beta$, $t$, $e_i$ et $F_i(X)$ dépendent de $r$), les inconnues étant les logarithmes des éléments de l'ensemble :
$$\mathcal{F} =  \gf{q} \cup \{F(\alpha) : F(X) \in \gf{q}[X] \text{ irréd. unitaire de degré au plus } d \}.$$
$\mathcal{F}$ est notre base de friabilité et son cardinal est plus petit que $q^{d+1}$. Nous nous servons de l'heuristique suivante pour borner le nombre de tirages nécessaires :
\begin{heur}
La création de $q^{d+1}$ équations de la forme (\ref{eqn:hellman-reyneri}) permet d'écrire un système n'admettant qu'une unique solution, formée des logarithmes en base $g$ des éléments de $\mathcal{F}$.
\end{heur}

Une fois que les logarithmes de la base $\mathcal{F}$ sont connus, nous cherchons le logarithme d'un élément arbitraire $h \in \gf{q^k}$ : il suffit d'avoir une relation de la même forme que (\ref{eqn:hellman-reyneri}) faisant intervenir $h$. On peut, par exemple, chercher le logarithme d'un élément $hg^r$ qui se factorise en éléments de la base $\mathcal{F}$ et déduire le logarithme de $h$ en soustrayant $r$ au résultat.

\begin{rema}
Normalement, les éléments de $\gf{q^k}$ dont l'ordre est un petit diviseur de $q^k-1$, comme les éléments de $\gf{q}$, sont écartés lors du crible : ils augmentent la possibilité d'apparition d'éléments non inversibles pour déterminer le logarithme des éléments de la base de friabilité, et des algorithmes tels que Pohlig-Hellman \cite{pohligHellman1978} ou rho de Pollard \cite{pollard1978} permettent déjà de les calculer facilement.
\end{rema}

Puisque la phase de calcul de logarithme discret individuel est négligeable comparée aux précalculs, il suffit, pour analyser la complexité asymptotique d'un tel algorithme, d'exprimer le coût de la collecte des relations et de l'algèbre linéaire en fonction du paramètre $d$. En majorant par $q^{d+1}$ la cardinalité de $\mathcal{F}$ et en désignant par $\mathbb{P}$ la probabilité qu'un polynôme aléatoire $G_r(X)$ soit $d$-fiable, le coût de l'exécution de la phase de collecte des relations est alors majoré par $q^{d+1}/\mathbb{P}$. En ce qui concerne l'algèbre linéaire, on remarque que le nombre d'éléments de la base de fiabilité dans n'importe laquelle des relations formées est majorée par $k$. Ceci provient du fait que le nombre de polynômes irréductibles qui apparaissent lorsque l'on factorise un polynôme est toujours inférieur à son degré. Aussi, l’algèbre linéaire que l'on exécute s'attache toujours à une matrice très creuse qui contient au plus $k$ termes non nuls par ligne. Le coût d'une telle méthode est alors quadratique en la taille de $\mathcal{F}$, si on utilise des techniques de calculs sur matrices creuses, comme par exemple la méthode du gradient conjugué. Plus précisément, le temps de calcul est majoré par $kq^{2d+2}$. De l'estimation de Panario-Gourdon-Flajolet \cite{PGF98}, on écrit :
$$-\log_q(\mathbb{P}) \leqslant\frac{k}{d}\log_q(k/d).$$
Par conséquent, si on choisit le paramètre :
$$d = \left\lceil \sqrt{ \frac{k\log_q k}{2} } \right\rceil,$$
on obtient comme complexité finale :
$$q^{\sqrt{(2+\o(1))k\log_qk}} = L_{q^k}(1/2,\sqrt 2).$$

\subsection{Algorithme de Coppersmith en $L_{q^k}(1/3)$}

L'algorithme de Don Coppersmith \cite{coppersmith1984} est plus efficace que l'algorithme de Hellman-Reyneri car il prend une représentation de $\gf{q^k}$ qui facilite la création de relations.

Coppersmith propose de choisir un polynôme irréductible $I_k(X)$ de la forme : $$X^k - S(X),$$ où $S(X) \in \gf{q}[X]$ est un polynôme de degré $d_S$ aussi petit que possible.

Cependant, Cécile Pierrot \cite{pierrot2016} indique divers résultats \cite{joux2006, joux2013} suggérant de choisir $I_k(X)$ comme facteur irréductible de $X^{q^n}-S(X)$. Détaillons : soit $n$ l'unique entier tel que $q^{n-1} < k \leqslant q^n$ et choisissons $S(X)$ de petit degré tel que $X^{q^n}-S(X)$ ait un facteur irréductible de degré $k$. Nous prenons alors ce facteur pour définir notre corps $\gf{q^k}$.

Décomposons $n = n_1 + n_2$ pour des valeurs $n_1$ et $n_2$ que l'on déterminera plus tard. L'idée pour la construction des relations est que pour chaque paire de polynômes $A(X)$ et $B(X)$ de $\gf{q}[X]$, on a l'égalité :
\begin{equation}\label{eqn:coppersmith}
{\left( A(X) + X^{q^{n_1}}B(X)\right)}^{q^{n_2}} = A(X^{q^{n_2}}) + S(X)B(X^{q^{n_2}}) \pmod{I_k(X)},
\end{equation}
grâce à la linéarité de l'élévation à la puissance $q$ (c'est l'automorphisme de Frobenius du corps $\gf{q}$) et à l'égalité $X^{q^n} = S(X) \pmod{I_k(X)}$.

Choisissons $g$ un générateur du groupe multiplicatif $\gf{q^k}^\times$ et un entier $d$ tel que $1 < d < k$. Prenons comme base de friabilité :
$$\mathcal{F} =  \{F(\alpha) : F(X) \in \gf{q}[X] \text{ irréductible unitaire de degré au plus } d \}.$$

L'équation (\ref{eqn:coppersmith}) donne une relation multiplicative nous contentant si les polynômes $A(X) + X^{q^{n_1}}B(X)$ et $A(X^{q^{n_2}}) + S(X)B(X^{q^{n_2}})$ sont $d$-friables, ou de manière équivalente, si le produit :
$$\left( A(X) + X^{q^{n_1}}B(X)\right)\left( A(X^{q^{n_2}}) + S(X)B(X^{q^{n_2}})\right)$$
est $d$-friable. Une fois de plus, nous supposons l'heuristique classique :
\begin{heur}\label{heur:polydfriable}
La probabilité que le produit $$\left( A(X) + X^{q^{n_1}}B(X)\right)\left( A(X^{q^{n_2}}) + S(X)B(X^{q^{n_2}})\right)$$ soit $d$-friable est identique à celle d'un polynôme aléatoire de même degré.
\end{heur}

Nous pouvons étudier les paires de polynômes non-nuls $A(X)$ et $B(X)$ de degré au plus $d$, avec $A(X)$ unitaire (car multiplier par un élément de $\gf{q}$ donne une équation identique). On cherche un couple $(n_1, n_2)$ d'entiers naturels minimisant le degré du produit de l'heuristique~\ref{heur:polydfriable}, i.e. :
$$d + q^{n_1} + d_S + \frac{dq^n}{q^{n_1}}.$$
Il est donc minimisé lorsque $q^{n_1}$ est aussi proche que possible de $\sqrt{dq^n}$. Un tel choix entraîne un degré asympototique de l'ordre de $(2+\o(1))\sqrt{dq^n}$, ce qui donne en fonction de $k$, un degré variant entre $(2+\o(1))\sqrt{dk}$ et $(2\sqrt{q}+\o(1))\sqrt{dk}$.
Si $d$ est choisi comme suit :
$$d = (4/3)^{1/3}q^{n/3}n^{2/3},$$
alors la complexité est $L_{q^{q^n}}(1/3, (32/9)^{1/3})$, ce qui donne en fonction de $k$ une complexité variant entre $L_{q^k}(1/3, (32/9)^{1/3})$ et $L_{q^k}(1/3, (32q/9)^{1/3})$.

Chaque relation multiplicative de la forme (\ref{eqn:coppersmith}) donne une équation du type :
$$q^{n_2} \sum_{F(\alpha) \in \mathcal{F}} e_i \log_g(F(\alpha)) = \sum_{F(\alpha) \in \mathcal{F}} e'_i \log_g(F(\alpha)) \pmod{q^k-1}.$$
Le système admet plusieurs solutions, et, à l'exception du vecteur nul, n'importe laquelle de celles-ci permet de recouvrer les logarithmes de la base de friabilité. En effet, si l'élément $g$ lui-même est dans la base $\mathcal{F}$, il est facile de normaliser le vecteur solution pour avoir les logarithmes en base $g$. En revanche, si $g$ n'appartient à $\mathcal{F}$, nous procédons à une phase de logarithme individuel sur $g$ pour déterminer la valeur de la constante de normalisation.

Par ailleurs, comme indiqué par Cécile Pierrot \cite{pierrot2016}, les gros coefficients $q^{n_2}$ ont un impact sur la performance des multiplications, mais dans de bonnes conditions (comme par exemple être en caractéristique 2) et avec un peu de ruse sur les multiplications matrice-vecteur, la phase d'algèbre linéaire n'est pas sensiblement ralentie.

Contrairement à l'algorithme de Hellman-Reyneri, la génération d'une relation faisant intervenir le logarithme d'un élément arbitraire du corps et ceux de la base de friabilité n'est pas facile dans la méthode de Coppersmith. Aussi apparaît une nouvelle notion essentielle : il s'agit de la \textit{notion de descente}. Ce procédé commence par écrire une relation entre notre élément arbitraire $h = H(\alpha)$ vu comme un polynôme en $\alpha$, l'élément primitif du corps cible $g = G(\alpha)$, et un petit nombre d'autres polynômes auxiliaires de petit degré. Par itérations successives, il devient alors possible d'exprimer le polynôme initial en produit d'éléments de la base de friabilité $\mathcal{F}$.

Par conséquent, le calcul d'un logarithme discret est maintenant représenté par un arbre dont les fils d'un n\oe ud, qui correspond à un polynôme, sont les n\oe uds des polynômes de plus bas degré apparaissant dans la relation associée. Toutes les feuilles de l'arbre doivent être dans $\mathcal{F}$.

Pour trouver une relation impliquant un polynôme $H(X)$ (où $H(\alpha) = h$ est l'élément cible dans $\gf{q^k}$), qui peut être supposé irréductible sans perte de généralité, nous procédons grossièrement de la façon suivante : \begin{itemize}
\item Choisir $n_1$ et $n_2$ deux entiers adaptés au degré de $H(X)$, et tel que $n = n_1 + n_2$,
\item Calculer une base $$((A_1(X), B_1(X)), (A_2(X), B_2(X)))$$ du réseau formé par l'ensemble des couples de polynômes $(A(X),B(X))$ tel que $H(X)$ divise $A(X) + X^{q^{n_1}}B(X)$.
\item Pour une paire de polynômes de petit degré $(\lambda_1(X), \lambda_2(X))$, poser
$$A(X) = \lambda_1(X)A_1(X) + \lambda_2(X)A_2(X) \quad\text{et}\quad B(X) = \lambda_1(X)B_1(X) + \lambda_2(X)B_2(X)$$ et considérer :
$${\left( A(X) + X^{q^{n_1}}B(X)\right)}^{q^{n_2}} = A(X^{q^{n_2}}) + S(X)B(X^{q^{n_2}}) \pmod{I_k(X)}.$$
Par linéarité, $H(X)$ divise le polynôme $A(X) + X^{q^{n_1}}B(X)$.
\item Parmi ces relations candidates, contenant toutes $H(X)$, garder seulement celles dont le degré de tous les polynômes irréductibles impliqués est plus petit que $\kappa \deg H(X)$, pour une certaine constante $\kappa$ (un choix classique est $\kappa = 3/4$).
\end{itemize}
La descente procède ainsi récursivement jusqu'à atteindre uniquement des éléments de la base de friabilité, à savoir des polynômes de degré inférieur ou égal à $d$.

\subsection{Crible par corps de fonctions}

Le crible par corps de fonctions est proposé en 1999 par Leonard Adleman et Ming-Deh Huang \cite{adleman1999}. Sans dénaturer l'idée des auteurs, nous présentons l'algorithme en utilisant des anneaux de polynômes et non des corps de fonctions, comme dans \cite{joux2013, joux2006, joux2002, pierrot2016}.

Le point de départ de l'algorithme réside une nouvelle fois dans la manière de définir le corps cible. L'idée consiste à construire l'extension à l'aide de deux relations polynômiales bivariées sur $\gf{q}$ : $$Y = f(X) \quad \text{et}\quad X = g(Y).$$
En assemblant ces deux relations, nous obtenons $X = g(f(X))$. Donc, si le polynôme $g(f(X)) - X$ possède un facteur irréductible $I_k(X)$ de degré $k$, nous pouvons représenter $\gf{q^k}$ à l'aide de celui-ci. Cela constitue notre heuristique :
\begin{heur}
Il existe deux polynômes $f(X)$ et $g(Y)$ dans $\gf{q}[X, Y]$ tels que le polynôme $g(f(X)) - X$ possède un facteur irréductible $I_k(X)$ de degré $k$.
\end{heur}
La représentation étant fixée, nous désignons par $\alpha$ l'une des racines dans $\gf{q^k}$ du polynôme $I_k(X)$ et nous posons $\beta = f(\alpha)$. Par construction nous avons $\alpha = g(\beta)$ dans $\gf{q^k}$. À partir de n'importe quelle paire de polynômes $A(X)$ et $B(X)$ univariés, nous pouvons écrire :
$$A(\alpha) + f(\alpha)B(\alpha) = A(g(\beta)) + \beta B(g(\beta)).$$
Nous obtenons ainsi une égalité dans $\gf{q^k}$ entre un polynôme en $\alpha$ et un second en $\beta$. De plus, chacun de ces deux polynômes est de degré relativement petit, si les paramètres sont bien choisis. Par conséquent, si chacun d'entre eux se factorise en produits de polynômes irréductibles de degrés au plus $d$, nous pouvons exploiter cette relation multiplicative. Soulignons que nous avons ici doublé la taille de la base de friabilité, puisqu'elle contient maintenant l'évaluation de chaque polynôme irréductible de petit degré en $\alpha$ et en $\beta$.

Les polynômes $A(X)$ et $B(X)$ sont à choisir de sorte que leur degré soit au plus $d$, tandis le degré de $f(X)$ et $g(Y)$ est choisi pour vérifier: $$\deg(f(X)) \deg(g(Y)) \approx k \quad\text{et}\quad \frac{\deg(f(X))}{\deg(g(Y))} \approx d.$$
L'optimisation non détaillée ici, donne une complexité asymptotique heuristique de :
$$L_{q^k}(1/3, (32/9)^{1/3}).$$

\subsection{Descente special-$\mathfrak{q}$}\label{s-sec:special-q}

La phase de descente décrite par Antoine Joux et Reynald Lercier \cite{joux2006, joux2002} nous servira dans la section suivante. Elle est donnée dans le cadre, et avec les notations, de l'algorithme précédent: le crible par corps de fonctions. Pour rappel, la phase de crible et d'algèbre linéaire sont finies et on souhaite maintenant déterminer le logarithme d'un élément arbitraire $h\in\gf{q^k}$, en l'exprimant à l'aide des éléments de la base de friabilité, que l'on note :
$$\mathcal{F} =  \{F(\gamma) : F(X) \in \gf{q}[X] \text{ irréductible unitaire de degré au plus } d \text{ et } \gamma \in \{\alpha, \beta\}\}.$$ 

Soient $H(X)\in\gf{q}[X]$ le polynôme tel que $H(\alpha) = h$. Considérons l'ensemble des monômes :
$$\mathcal S_H = \{X^iY^j : 0 \leqslant i \leqslant D_\alpha(H), 0 \leqslant j \leqslant D_\beta(H)\},$$
où $D_\alpha(H)$ et $D_\beta(H)$ sont des paramètres que nous déterminerons plus tard. Chaque monôme dans $\mathcal S_H$ peut être exprimé comme un polynôme univarié en $X$ en substituant $Y$ par $f(X)$. Pour $m(X,Y)$ un monôme de $\mathcal S_H$, notons $V_H(m)(X)$ la valeur modulo $H(X)$ du polynôme univarié correspondant à $m(X,Y)$, i.e. 
$$V_H(m)(X) := m(X,f(X)) \pmod{H(X)}.$$
Clairement, $V_H(m)(X)$ peut être représenté par un vecteur $V_H(m)$ à $\deg(H(X))$ coefficients dans le corps fini $\gf{q}$. Construisons une matrice $M_H$ dont les colonnes sont les vecteurs $V_H(m)$ pour $m(X,Y) \in \mathcal S_H$. Concrètement, la matrice $M_H$ contient en colonnes des restes de divisions euclidiennes par le polynôme $H(X)$. N'importe quel vecteur du noyau de $M_H$ peut être alors interprété comme combinaison linéaire de ces restes modulo $H(X)$. Ainsi, à chaque vecteur du noyau de $M_H$, on peut associer une combinaison linéaire d'éléments de $\mathcal S_H$ qui est un polynôme $U(X,Y)$, tel que $U(X,f(X))$ est divisible par $H(X)$. Si, à la fois, les polynômes $U(X,f(X))/H(X)$ et $U(g(Y),Y)$, se factorisent en polynômes de degré au plus $d$, nous obtenons la relation désirée.

L'étude faite dans \cite{joux2006, joux2002} et rappelée dans \cite{joux2013}, donne :
$$D_\alpha(H) D_\beta(H) \geqslant \deg H(X) \quad\text{et}\quad \frac{D_\beta(H)}{D_\alpha(H)} \approx d.$$

\begin{rema}
L'exposé fait ici avec $H(X)\in\gf{q}[X]$ tel que $H(\alpha) = h$, peut aussi être fait avec $H(Y)\in\gf{q}[Y]$ tel que $H(\beta) = h$, en gardant à l'esprit que $X = g(Y)$ et $Y = f(X)$, et en intervertissant les rôles de $D_\alpha$ et $D_\beta$.
\end{rema}
\begin{rema}
Le coût de cette descente augmente lorsque le degré de $H(X)$ diminue.
\end{rema}

\subsection{Algorithme de Joux en $L_{q^k}(1/4)$}\label{s-sec:algoJoux}

Nous arrivons enfin à l'algorithme en $L_{q^k}(1/4 + \o(1))$ décrit par Antoine Joux. Dans l'article \cite{joux2013}, il commence par rafraichir la mémoire du lecteur sur l'algorithme de Coppersmith et le crible par corps de fonctions. Ensuite il présente prosaïquement les nouvelles idées de son algorithme, suivies par une description plus rigoureuse insistant sur la phase de crible et sur la phase de descente pour le calcul de logarithme individuel. Il conclut par l'étude de la complexité, en faisant remarquer que la phase la plus coûteuse devient la descente. Il clôture son exposé par quelques exemples.

L'un des changements de paradigme majeurs par rapport aux autres algorithmes présentés avant est la construction et non plus la recherche de polynômes friables.

Rappelons ici qu'il existe un algorithme quasi-polynomial, faisant l'objet de l'article \cite{barbulescu2013}, dont l'étude n'est pas faite.

\subsubsection{Présentation des idées de Joux}\label{ss-sec:idees}

Nous présentons ici les idées sur lesquelles repose l'algorithme.

\paragraph{Idée 1: les homographies.} Si on a un polynôme qui se factorise, on souhaite le transformer en d'autres polynômes qui se factorisent eux aussi. Pour cela, on considère la transformation induite par les homographies, à savoir :
$$X \mapsto \frac{aX+b}{cX+d}.$$
Cependant, faire ce changement de variable ne donne pas un polynôme : si $f(X) \in\gf{q}[X]$ est un polynôme, ce n'est pas forcement le cas de $f((aX+b)/(cX+d))$. Ainsi, nous considérons plutôt l'évaluation homogène d'un polynôme, i.e. pour un polynôme $f(X)$ de $\gf{q}[X]$, dont on note $\deg f$ le degré, on considère le polynôme :
$$F_{a,b,c,d}(X) := (cX+d)^{\deg f} f \left(\frac{aX+b}{cX+d}\right).$$
Formalisons cela en le théorème suivant :
\begin{theo}
Soient $f(X) \in \gf{q}[X]$ un polynôme unitaire et $\gf{q^k}$ une extension de $\gf{q}$. Soit $(a,b,c,d) \in \gf{q^k}^4$ tel que $ad \neq bc$ et considérons le polynôme :
$$F_{a,b,c,d}(X) := (cX+d)^{\deg f} f \left(\frac{aX+b}{cX+d}\right).$$
Si le polynôme $f(X)$ admet la factorisation en produit de polynômes irréductibles unitaires : $$f(X) = \prod_{i=1}^k F_i(X)^{e_i},$$
alors le polynôme $F_{a,b,c,d}(X)$ admet la factorisation suivant :
$$F_{a,b,c,d}(X) = \prod_{i=1}^k {\left( (cX+d)^{\deg F_i} F_i\left(\frac{aX+b}{cX+d}\right)\right)}^{e_i}.$$
Remarquons que les facteurs de cette décomposition ne sont pas nécessairement unitaires, ni irréductibles, et qu'ils peuvent avoir un degré plus petit que le facteur correspondant.
\end{theo}
\begin{proof}
La factorisation induite est claire : il suffit de faire le changement de variable de chaque côté et de remarquer que les termes :
$$(cX+d)^{\deg F_i} F_i\left(\frac{aX+b}{cX+d}\right)$$
sont en effet des polynômes. Visiblement, il n'y a aucune raison pour que les facteurs ainsi transformés soient irréductibles dans $\gf{q^k}[X]$. Remarquons que lorsque $c \neq 0$, le coefficient de $X^{\deg{F_i}}$ venant de $F_i$ est $c^{\deg F_i}F_i(a/c)$. Comme il n'est pas nécessairement égal à $1$ et peut même être nul, on observe que les facteurs transformés ne sont pas nécessairement unitaires et peuvent être de degré strictement inférieur à celui du $F_i$ correspondant.
\end{proof}

\paragraph{Idée 2: un polynôme toujours scindé.} La seconde idée découle directement de la première. Comme on sait faire plusieurs ``copies'' d'un polynôme, on souhaite considérer un polynôme qui se factorise agréablement. Sur $\gf{q}$, un candidat naturel est : $$X^q -X = \prod_{\gamma\in\gf{q}} X-\gamma.$$

\paragraph{Idée 3: une bonne représentation du corps.} L'image de $X^q-X$ par une homographie est un polynôme combinaison linéaire des monômes $X^{q+1}$, $X^q$, $X$ et $1$. Pour obtenir une relation multiplicative, on désire donc trouver une représentation du corps fini qui transforme le polynôme $X^q - X$ en un polynôme de bas degré. Une façon de faire est de demander la satisfaction dans $\gf{q^k}$ de la relation :
$$x^q = \frac{h_0(x)}{h_1(x)}.$$
Cela défini le corps $\gf{q^k}$ si, et seulement si, le polynôme $h_1(X)X^q - h_0(X)$ admet un facteur irréductible $I_k(X)$ de degré $k$, et alors $x = X \pmod{I_k(X)}$ vérifie bien la relation demandée.

\subsubsection{Description de l'algorithme}

L'algorithme de Joux combine les idées précédentes pour calculer des logarithmes discrets dans des corps de petite caractéristique. La description laisse de côté l'étude de la phase d'algèbre linéaire: une fois de plus, le lecteur est invité à consulter les travaux de Don Coppersmith, Andrew Odlyzko, et Richard Schroeppel \cite{coppersmith1986} et de Douglas Wiedemann \cite{wiedemann1986}.

\paragraph{Choix des paramètres.}Étant donné un corps $\gf{p^n}$ de petite caractéristique, nous commençons par l'imbriquer dans un corps de la forme $\gf{q^{2k}}$, avec $k \leqslant q$. Cela se fait, par exemple, en prenant une extension de degré $e$ de $\gf{p^n}$, où $e \leqslant 2 \ceil{\log_p n}$.

Ensuite, le corps fini $\gf{q^{2k}}$ est construit comme une extension de degré $k$ de $\gf{q^2}$. Plus précisément, nous appliquons la troisième idée du paragraphe~\ref{ss-sec:idees} : on choisit deux polynômes $h_0(X)$ et $h_1(X)$ de $\gf{q^2}[X]$ de bas degré de sorte que $h_1(X)X^q - h_0(X)$ ait un facteur irréductible $I_k(X)$ de degré $k$.
\begin{heur}
Quel que soit le degré de l'extension $k$, on peut trouver $h_0(X)$ et $h_1(X)$  tel que $h_1(X)X^q - h_0(X)$ ait un facteur irréductible de degré $k$.
\end{heur}
Et en fait, Antoine Joux \cite{joux2013} indique que nous pouvons même nous limiter aux polynômes de degré 2, et espérer malgré tout avoir une bonne représentation de notre corps.

\paragraph{Logarithmes des polynômes linéaires.}Nous voulons déterminer les logarithmes de tous les polynômes linéaires de notre corps. Pour cela, nous construisons des relations multiplicatives entre de tels éléments, en utilisant la première et la seconde idées du paragraphe~\ref{ss-sec:idees}.

Pour générer de telles relations, partons de l'identité polynomiale:
\begin{equation}\label{eqn:identitySplit}
\prod_{\gamma\in\gf{q}} X-\gamma = X^q-X,
\end{equation}
et appliquons la transformation homographique $X \mapsto (aX+b)/(cX+d)$, où $(a,b,c,d)\in\gf{q^2}^4$ satisfait à $ad\neq bc$, puis multiplions par $(cX+d)^{q+1}$, ce qui donne d'une part, en prenant seulement le membre de gauche de l'équation~\ref{eqn:identitySplit} :
\begin{align*}
(cX+d)^{q+1} \prod_{\gamma\in\gf{q}} \left(\frac{aX+b}{cX+d}-\gamma\right) &= (cX+d) \prod_{\gamma\in\gf{q}} (aX+b-\gamma(cX+d)), \\ 
&= (cX+d) \prod_{\gamma\in\gf{q}} ((a-\gamma c)X+b-\gamma d),\\
\end{align*}
et d'autre part, en considérant uniquement le membre de droite :
\begin{align*}
(cX+d)^{q+1}\left({\left(\frac{aX+b}{cX+d}\right)}^q - \frac{aX+b}{cX+d}\right) &= (aX+b)^q(cX+d) - (aX+b)(cX+d)^q. \\
\end{align*}
D'où enfin :
$$(cX+d) \prod_{\gamma\in\gf{q}}((a-\gamma c)X + (b-\gamma d)) = (aX+b)^q(cX+d) - (aX+b)(cX+d)^q.$$
Développons le membre de droite de cette dernière équation et réduisons modulo $I_k(X)$ :
$$a^qcX^{q+1} + a^qdX^q + b^qcX + b^qd - ac^qX^{q+1} - ad^qX - bc^qX^q - bd^q$$
$$= (a^qc - ac^q)X^{q+1} + (a^qd - bc^q)X^q + (b^qc - ad^q)X + b^qd - bd^q,$$
$$\equiv (a^qc - ac^q)X\frac{h_0(X)}{h_1(X)} + (a^qd - bc^q)\frac{h_0(X)}{h_1(X)} + (b^qc - ad^q)X + b^qd - bd^q \pmod{I_k(X)}.$$
Cela nous donne l'égalité, modulo $I_k(X)$, suivante:
$$\frac{(a^qc - ac^q)Xh_0(X) + (a^qd - bc^q)h_0(X) + (b^qc - ad^q)Xh_1(X) + (b^qd - bd^q)h_1(X)}{h_1(X)}$$
$$= (cX+d) \prod_{\gamma\in\gf{q}}((a-\gamma c)X + (b-\gamma d)).$$
Par conséquence, nous obtenons une égalité dans $\gf{q^2}[X]/(I_k(X)) \cong \gf{q^{2k}}$ entre un produit de polynômes linéaires et une fraction avec un numérateur de bas degré et un dénominateur constant. En ajoutant $h_1(X)$ à la base de friabilité, nous obtenons une relation satisfaisant dès que le membre de gauche se factorise en polynômes linéaires.

\paragraph{Comptage des relations.}La description ci-dessus génère une relation candidate pour chaque quadruplet $(a,b,c,d) \in \gf{q^2}^4$. Cependant, certaines de ses relations sont générées plusieurs fois, avec des $(a,b,c,d)\in\gf{q^2}^4$ distincts. Par exemple, si $(a,b,c,d)\in\gf{q}^4$, nous obtenons une équation triviale.

Pour cette raison, Joux \cite{joux2013} préconise de prendre les coefficients $a,b,c,d$ dans $\gf{q^2}$. En étudiant l'action de $\operatorname{PGL}_2(\gf{q^2})$ sur la droite projective $\mathbb{P}_1(\gf{q})$ et du fait que $\operatorname{PGL}_2(\gf{q})$ laisse $\mathbb{P}_1(\gf{q})$ globalement invariant, Joux déduit le nombre d'équations candidates : 
$$\frac{q^6 - q^2}{q^3 - q} = q^3 + q.$$
Après un argument heuristique, Joux \cite{joux2013} explique qu'il suffit de considérer $\O(q^2)$ quadruplets, en évitant ceux donnant des duplicatas, pour pouvoir passer à la phase d'algèbre linéaire sur les logarithmes des polynômes linéaires.

\paragraph{Étendre la base aux polynômes de degré $2$.} Si nous appliquons la même stratégie que précédemment, nous tombons sur un os. En effet, on pourrait garder les relations comprenant à la fois des polynômes de degré $1$ et de degré $2$. Mais, étant donné qu'il y a $\O(q^4)$ polynômes irréductibles de degré $2$ à coefficients dans $\gf{q^2}$ et qu'on ne peut fabriquer que $\O(q^3)$ relations par la méthode précédente, en enlevant les duplicatas, il serait impossible de recouvrer le logarithme de tous les polynômes irréductibles de degré $2$.

Une stratégie qui fonctionne est d'accomplir la transformation suivante :
$$X \mapsto \frac{a(X^2+\theta X) + b}{c(X^2 + \theta X) +d},$$
pour $\theta \in \gf{q^2}$ et $(a,b,c,d) \in \gf{q^2}^4$. Ce que Joux \cite{joux2013} fait ici est qu'il partitionne l'ensemble des polynômes de degré $2$ en plusieurs sous-ensembles, indexés par $\theta$. Après ce changement dans l'équation~\ref{eqn:identitySplit}, le membre de gauche se factorise en  produit d'une constante de $\gf{q^2}$ et de polynômes irréductibles de degré $2$ ayant la forme $X^2 + \theta X + \kappa \in \gf{q^2}[X]$. Si nous gardons seulement les relations où le membre de droite se factorise en polynômes linéaires, nous pouvons déterminer les logarithmes des polynômes $X^2 +\theta X + \kappa$ irréductibles, où $\theta$ est fixé. Cela nous fait résoudre $q^2$ systèmes (un pour chaque $\theta$) de taille $\O(q^2)$ chacun.

\paragraph{Phase 0: étape facultative préliminaire à la descente.}Avant de commencer la descente proprement dite, il peut être utile de trouver un bon représentant de l'élément $h$ dont nous souhaitons déterminer le logarithme. Tout d'abord, $h = H(\alpha)$ est écrit comme un polynôme de degré au plus $k-1$ sur $\gf{q^2}$, où $\alpha$ est une racine fixée de $I_k(X)$ et $H(X) \in \gf{q^2}[X]$. S'il n'est pas satisfaisant, supposons que la base de logarithme que nous choisissons est l'élément primitif $g$, on peut considérer plutôt la représentation polynomiale de $hg^r$, en faisant varier $r$ jusqu'à ce que l'on ait une décomposition en polynômes convenable.

\paragraph{Phase 1: descente special-$\mathfrak{q}$.}La première phase de descente fait appel à la descente special-$\mathfrak{q}$, déjà exposée au paragraphe~\ref{s-sec:special-q}. Cependant, nous ne possédons pas de seconde indéterminée $Y$. Il faut donc créer $Y$ en fonction de $X$. Joux \cite{joux2013} précise que la méthode que nous nous apprêtons à exposer, ne marche que dans le cas d'un corps de petite caractéristique.

Notons $p$ la caractéristique du corps fini, soit $\ell$ tel que $q = p^\ell$ et posons $r := \floor{\ell/2}$. Si $Y = X^{p^{r}}$ alors, par définition de notre corps:
$$Y^{qp^{-r}} = X^q = \frac{h_0(X)}{h_1(X)}.$$
Si $h_0(X)$ ou $h_1(X)$ est de degré $2$ ou plus, il faut recourir à un légère variation par rapport à la descente special-$\mathfrak{q}$. À	savoir, là où dans \ref{s-sec:special-q} on considérer une relation de la forme $U(X,f(X)) = U(g(Y),Y)$, on considère plutôt la relation:
$${\left({U(X,X^{p^r})}\right)}^{qp^{-r}} = U'\left( X^{qp^{-r}},\frac{h_0(X)}{h_1(X)}\right),$$
où $U'(X,Y) \in \gf{q^2}[X,Y]$ est obtenu à partir de $U(X,Y)\in \gf{q^2}[X,Y]$ en élevant ses coefficients à la puissance $qp^{-r}$.

Comme cette méthode est coûteuse si nous souhaitons atteindre les éléments de la base de friabilité, Antoine Joux \cite{joux2013} introduit une nouvelle méthode à employer lorsque nous avons affaire à des polynômes de degré bas, mais pas encore dans la base de friabilité.

\paragraph{Phase 2: descente basée sur un système bilinéaire.}L'idée de cette descente qui vient compléter la descente classique précédente est: étant donné un polynôme $H(X)$, nous cherchons une paire de polynômes de bas degré, $k_1(X)$ et $k_2(X)$, de $\gf{q^2}[X]$, tels que $H(X)$ divise la différence $(k_1(X)^qk_2(X)-k_1(X)k_2(X)^q) \pmod{I_k(X)}$. Ainsi, la relation:
$$(k_1(X)^qk_2(X)-k_1(X)k_2(X)^q) \equiv (k_1(X)^qk_2(X)-k_1(X)k_2(X)^q) \pmod{I_k(X)}.$$
a un facteur égal à $H(X)$ dans le membre de droite et le membre de gauche se factorise en polynômes de degré au plus $D := \max(\deg k_1, \deg k_2)$. Comme le degré total du membre de droite est majoré par un petit multiple de $D$ (lié au degré de $h_0$ et $h_1$), avec un bonne probabilité, nous obtenons une relation polynomiale entre $H(X)$ et des polynômes de degré au plus $D$.

Reste à construire de tels polynômes $k_1(X)$ et $k_2(X)$. Antoine Joux \cite{joux2013} remarque que la condition $(k_1(X)^qk_2(X)-k_1(X)k_2(X)^q) \pmod{I_k(X)}$ s'annule modulo $H(X)$ se réécrit comme un système d'équations multivariées sur $\gf{q}$, qui peut être efficacement résolue par des méthodes de résolutions à l'aide de bases de Gröbner. 
Ce système est même bilinéaire en $k_1(X)$ et $k_2(X)$ puisque chaque monôme qui apparaît dans le système contient au plus une inconnue provenant de $k_1(X)$ et une de $k_2(X)$.

Plus précisément, considérons chaque coefficient de $k_1(X)$ et $k_2(X)$ comme une indéterminée appartenant au corps des coefficients $\gf{q^2}$. Si $x$ est une telle inconnue, nous l'écrivons $x_0 + zx_1$, où $(1,z)$ est une base de $\gf{q^2}$ sur $\gf{q}$, et $x_0$ et $x_1$ sont des inconnues appartenant à $\gf{q}$. Avec une telle convention: $$x^q = x_0 + z^qx_1.$$
Le système a $\deg H(X)$ équations sur $\gf{q^2}$ et peut s'écrire comme un système à $2\deg H(X)$ équations sur $\gf{q}$. En supposant que $k_1(X)$ est unitaire, le nombre maximum d'inconnues est $2(\deg k_1(X) + \deg k_2(X) + 1)$. Cependant, à cause de l'action de $\operatorname{PGL}_2(\gf{q})$, plusieurs couples $(k_1(X),k_2(X))$ distincts donnent le même polynôme $(k_1(X)^qk_2(X)-k_1(X)k_2(X)^q)$. Pour éviter cela, il faut fixer au moins une inconnue dans $\gf{q^2} - \gf{q}$, laissant ainsi $2(\deg k_1(X) + \deg k_2(X))$ inconnues dans $\gf{q}$. 

Antoine Joux \cite{joux2013} fait ensuite un raisonnement heuristique pour avoir une bonne probabilité que le système précédent admette une solution, à savoir: nous avons besoin que 
$$\deg k_1(X) + \deg k_2(X) \geqslant \deg H(X) + 1.$$
Enfin, il étudie la complexité de la descente. Pour cela, il s'appuie sur les travaux de Jean-Charles Faugère, Mohab Safey El Din et Pierre-Jean Spaenlehauer, dont le résultat principal dans \cite{faugere2011, spaenlehauer2012} donnent que la complexité est exponentielle en $\min(\deg k_1(X), \deg k_2 (X))$.
Plus précisément, en posant $d = \deg k_2(X)$ et donc $\deg k_1(X) = \deg H(X) +1 - d$, la complexité est :
$$\binom{2 (\deg H(X)) + 3}{2d+1}^\omega,$$
où $2 \leqslant \omega \leqslant 3$ est une constante. 
Le choix de $d$ est donné dans la section suivante.

\subsubsection{Analyse de la complexité}

\section{Les conséquences pour le cryptosystème de Chor-Rivest}\label{sec:consequences}

L'exposition du cryptosystème en section~\ref{sec:cryptosysteme}, la cryptanalyse de Serge Vaudenay en section~\ref{sec:cryptanalyse} et l'algorithme d'Antoine Joux en section~\ref{sec:DLPJoux}, nous incite à prendre $p$ et $h$ deux nombres premiers et tels que $h \leqslant p$ pour ``réparer'' le cryptosystème.

%Donner résultats précédents sur les tentatives d'amélioration (Madrid)

\subsection{Idées théoriques}

\paragraph{Prélude.} La confection de la clé publique du cryptosytème requière le calcul de logarithmes dans $\gf{p^h}$. Nous aimerions tirer avantage de la particularité de ces logarithmes, à savoir qu'on veut déterminer le logarithme d'éléments de la forme $t + \alpha$, où $t$ est tel que $\gf{p^h} = \gf{p}[t]$ et où $\alpha \in \gf{p}$. Essentiellement, si nous reprenons les notations de \ref{sec:cryptosysteme} et \ref{s-sec:algoJoux}, on souhaite grossièrement que $t = X \pmod{I_k(X)}$, avec $k = h$. En effet, grâce à cela, en nous ayant recourt à l'algorithme de Joux, il suffirait de ne faire que la première partie du crible: la collecte de relation entre polynômes linéaires. Malheureusement, on s’aperçoit immédiatement qu'il y a a priori un problème, car dans le cryptosystème $t \in \gf{p^h}$, alors que $I_k(X)$ n'est pas un polynôme à coefficient dans $\gf{p}$. Nous nous proposons d'explorer cette idée, qui, si elle porte ses fruits, permettrait de surmonter l'obstacle du calcul des logarithmes. Nous examinerons après si cela rend vulnérable le cryptosystème.

\paragraph{Rappels.}La génération de la clé privée consiste à choisir:
\begin{enumerate}
\item un générateur $g$ du groupe cyclique $\gf{p^h}^\times$,
\item un élément $t \in \gf{p^h}$ algébrique de degré $h$ sur $\gf{p}$,
\item une permutation $\sigma$ de l'ensemble $\{0, \dots, p-1\}$,
\item un entier $d$ tel que $0 \leqslant d \leqslant p^h-2$.
\end{enumerate}
et la clé publique est formée des:
$$c_i := d + \log_g\left(t + \alpha_{\sigma(i)}\right) \pmod{p^h-1}, \qquad 0 \leqslant i \leqslant p-1.$$
Clairement, les éléments intéressant ici sont $g$ et $t$.

\paragraph{Adaptation.} Étant donné que $h \leqslant p$, nous pouvons imbriquer $\gf{p^h}$ dans $\gf{p^{2h}}$, et satisfaire à la toute première étape de l'algorithme. Nous faisons donc une extension quadratique de $\gf{p^h}$, puis on cherche un polynôme irréductible convenable $I_h(X)\in\gf{p^2}[X]$, divisant $h_1(X)X^p - h_0(X)$, représentant l'extension de corps $\extension{\gf{p^{2h}}}{\gf{p^2}}$. Cela donne le diagramme :
\begin{figure}[h]
\begin{center}
\begin{tikzpicture}
\coordinate (Fp) at (0,0) ;
\coordinate (Fph) at (-1.5,1.5) ;
\coordinate (Fp2h) at (0,3) ;
\coordinate (Fp2) at (1.5,1.5) ;
\draw (Fp) node[below]{$\gf{p}$} node{$\bullet$} ;
\draw (Fph) node[left]{$\gf{p^h}$} node{$\bullet$} ;
\draw (Fp2h) node[above]{$\gf{p^{2h}}$} node{$\bullet$} ;
\draw (Fp2) node[right]{$\gf{p^2}$} node{$\bullet$} ;
\draw[thick, ->, >= latex] (Fp) -- (Fp2) ;
\draw[thick, ->, >= latex] (Fp) -- (Fph) ;
\draw[thick, ->, >= latex] (Fp2) -- (Fp2h) ;
\draw[thick, ->, >= latex] (Fph) -- (Fp2h) ;
\end{tikzpicture}
\end{center}
\end{figure}

Comme indiqué dans le prélude, nous aimerions pouvoir prendre $t = X \pmod{I_h(X)}$. Le seul écueil est que $I_h(X)$ est à coefficients dans $\gf{p^2}$. Cependant, la résultat suivant permet d'obtenir satisfaction:
\begin{prop}
Un polynôme irréductible de degré $h$ sur $\gf{p}$ est irréductible sur $\gf{p^2}$ si, et seulement si, $h$ est impair.
\end{prop}
Cela permet dont de choisir $I_h(X)$ comme un facteur irréductible de degré $h$ du polynôme $h_1(X)X^p-h_0(X) \in \gf{p}[X]$. Donc, si on pose $t = X \pmod{I_h(X)}$, la représentation de $\gf{p^{2h}}$ est $$\frac{\gf{p^2}[X]}{(I_h(X))} = \gf{p^2}(t).$$

Ainsi, il ne reste plus qu'à choisir l'élément primitif $g$. Comme l'algorithme de Joux permet de trouver les logarithmes dans $\gf{p^{2h}}$, si on choisit aléatoirement $\gamma \in \gf{p^{2h}}$ primitif et que l'on pose $g = \gamma^{(p^{2h}-1) / (p^h-1)} = \gamma^{p^h+1}$, alors $g$ engendre $\gf{p^h}^\times$ et il suffit de prendre les logarithmes en base $\gamma$ est de les réduire modulo $p^h-1$.

\subsection{Implémentation spécifique de l'algorithme}

Pour fixer les idées, nous donnerons en \verb|sage| les commandes\footnote{Elles sont toutes dans le fichier \textit{joux-algorithm.sage} sous forme de fonction.} utilisées pour effectuer les différents calculs. Il est cependant nécessaire de déclarer les variables \verb|p| et \verb|k|:
\begin{verbatim}
sage: p = 13 # peu importe les valeurs, il faut juste des nombres premiers
sage: k = 5 # joue le rôle du h, degré de l'extension
\end{verbatim}

Commençons par l'imbrication de corps. Dans \verb|sage| cela donne:
\begin{verbatim}
sage: Fp2.<alpha> = GF(p ** 2)
sage: FpY.<Y> = PolynomialRing(GF(p))
sage: Fp2X.<X> = PolynomialRing(Fp2)
\end{verbatim}
On cherche deux polynômes $h_0(X)$ et $h_1(X)$ tels que $h_1(X)X^p - h_0(X)$ ait un facteur irréductible de degré $h$, ici on cherche même $h_1(X)$ affine pour qu'il soit dans la base de friabilité:
\begin{verbatim}
sage: while true :
sage:     h0 = FpY.random_element(2)
sage:     h1 = FpY.random_element(1)
sage:     fa = list((h1 * Y ** p - h0).factor())
sage:     deg = [ poly.degree() for poly, mult in fa ]
sage:     if k in deg :
sage:         break
sage: Ik = fa[deg.index(k)][0]
\end{verbatim}
La représentation en \verb|sage| donne:
\begin{verbatim}
sage: Fp2k.<beta> = Fp2X.quotient_ring(Fp2X(Ik))
\end{verbatim}

\paragraph{Crible.}Dans son article \cite{joux2013}, Antoine Joux propose de garder des \textit{hashs} de nos relations pour ne pas avoir de duplicatas. C'est ce que nous faisons. Pour rappel de la méthode, nous choisissons $(a,b,c,d) \in \gf{p^2}$, et nous avons l'égalité modulo $I_h(X)$ entre, d'une part:
\begin{equation}\label{eqn:exemAlgoJoux}
(a^qc - ac^q)Xh_0(X) + (a^qd - bc^q)h_0(X) + (b^qc - ad^q)Xh_1(X) + (b^qd - bd^q)h_1(X)
\end{equation}
et d'autre part:
$$h_1(X)(cX+d) \prod_{\gamma\in\gf{q}}((a-\gamma c)X + (b-\gamma d))$$
et nous ne gardons que les relations où le polynôme \ref{eqn:exemAlgoJoux} se factorise en polynômes linéaires. Et il nous faut approximativement $p^2$ telles relations.

Voici d'abord un petit bout de code \verb|sage| permettant de déterminer si un polynôme est scindé:
\begin{verbatim}
sage: def is_split (P) :
sage:     fa = list(P.factor())
sage:     deg = [ poly.degree() for poly, mult in fa ]
sage:     deg = set(deg)
sage:     if deg == {1} :
sage:         return True
sage:     else :
sage:         return False
\end{verbatim}
Définissons les variables dans \verb|sage|:
\begin{verbatim}
sage: sieveSize = p ** 2
sage: nbIter = 0
sage: hashTable = []
sage: sieveTable = []
\end{verbatim}
Et commençons le crible\footnote{le \textit{print} n'est pas obligatoire, il indique un pourcentage d'exécution.}:
\begin{verbatim}
sage: h0 = Fp2X(h0)
sage: h1 = Fp2X(h1)
sage: while nbIter < sieveSize :
sage:     a = Fp2.random_element()
sage:     b = Fp2.random_element()
sage:     c = Fp2.random_element()
sage:     d = Fp2.random_element()
sage:     if a * d != b * c :
sage:         P = Fp2X((c * a ** p - a * c ** p) * X * h0
sage:                + (d * a ** p - b * c ** p) * h0
sage:                + (c * b ** p - a * d ** p) * X * h1
sage:                + (d * b ** p - b * d ** p) * h1)
sage:         if is_split (P) :
sage:             Q = Fp2X(c * X + d) * h1
sage:             for gamma in range (p) :
sage:                 Q *= ((a - gamma * c) * X + b - gamma * d)
sage:             if [hash(P), hash(Q)] not in hashTable :
sage:                 hashTable.append([hash(P), hash(Q)])
sage:                 sieveTable.append([ [(P.lc(), 1)] + list(factor(P)) ]
sage:                                 + [ [(Q.lc(), 1)] + list(factor(Q)) ])
sage:                 nbIter += 1
sage:                 print (nbIter * 100 / sieveSize).n(digits=3)
\end{verbatim}

\paragraph{Relations.}On souhaite avoir des relations seulement entre les polynômes linéaires unitaires, sans les coefficients de $\gf{p^2}$. Pour cela, nous déterminons leur logarithme. Nous allons fixer un élément primitif $g \in \gf{p^{2h}}$, où: $$\gf{p^{2h}} = \frac{\gf{p^2}[X]}{(I_h(X))}.$$
Cependant, les éléments de \verb|Fp2k| ont certaines méthodes qui ne sont pas implémentées, comme par exemple \verb|.multiplicative_order()| ou \verb|.is_primitive()|. Nous les faisons:
\begin{verbatim}
sage: def multorder (x) :
sage:     A = x.parent()
sage:     card = A.cardinality()
sage:     if card.parent() != ZZ :
sage:         raise ArithmeticError("ring not finite")
sage:     return recursive_multorder (x, card - 1, prime_factors (card - 1))

sage: def recursive_multorder (x, order, prime_fa) :
sage:     A = x.parent()
sage:     for p in prime_fa :
sage:         if x ** (order / p) == A.one() :
sage:             return recursive_multorder (x, order / p, 
sage:                    [ f for f in prime_fa if (order / p) % f == 0 ])
sage:     return order

sage: def is_primitive (x) :
sage:     A = x.parent()
sage:     card = A.cardinality()
sage:     if card.parent() != ZZ :
sage:         raise ArithmeticError("ring not finite")
sage:     card = card - 1
sage:     for p in prime_factors(card) :
sage:         if x ** (card / p) == A.one() :
sage:             return False
sage:     return True
\end{verbatim}
Nous pouvons maintenant choisir un élément primitif $g \in \gf{p^{2h}}$:
\begin{verbatim}
sage: while True :
sage:     g = Fp2k.random_element()
sage:     if is_primitive(g) :
sage:         break
\end{verbatim}
Pour nous débarrasser des facteurs de $\gf{p^2}$ dans notre système, nous déterminons les logarithmes en base $g$ de ceux-ci. Cela se fait à l'aide, par exemple, de l'algorithme de Pohlig-Hellman \cite{pohligHellman1978}, que nous n'écrivons pas ici. Après avoir attaché le fichier \textit{joux-algorithm.sage} à \verb|sage|, écrire la commande:
\begin{verbatim}
sage: baseFieldLogs = get_base_field_logs (g)
\end{verbatim}
Maintenant, nous pouvons reformuler le système obtenu par le crible. Nous en faisons un semblable à celui de l'algorithme de Hellman-Reyneri \cite{hellman1982}:
\begin{verbatim}
sage: unknownsSide = []
sage: solutionSide = []
sage: for left, right in sieveTable :
sage:     linear_poly = []
sage:     sol = 0
sage:     for poly, mult in left :
sage:         if poly in baseFieldLogs[0] :
sage:             sol = Integer(mod (sol - mult * baseFieldLogs[1]
sage:                   [baseFieldLogs[0].index(poly)], p ** (2 * k) - 1))
sage:         else :
sage:             linear_poly += [ (poly, mult) ]
sage:     for poly, mult in right :
sage:         if poly in baseFieldLogs[0] :
sage:             sol = Integer(mod (sol + mult * baseFieldLogs[1]
sage:                   [baseFieldLogs[0].index(poly)], p ** (2 * k) - 1))
sage:         else :
sage:             linear_poly += [ (poly, -mult) ]
sage:     unknownsSide += [linear_poly]
sage:     solutionSide += [sol]
\end{verbatim}

\paragraph{Algèbre linéaire.}Il est possible de composer la base de friabilité et la matrice du système:
\begin{verbatim}
sage: basis = []
sage: for line in unknownsSide :
sage:    for poly, mult in line :
sage:        basis.append(poly)
sage: basis = list(set(basis))

sage: M = Matrix(IntegerModRing(p ** (2 * k) - 1), 
sage:            len(unknownsSide), len(basis), sparse=True)
sage: i = 0
sage: for line in unknownsSide :
sage:      for poly, mult in line :
sage:          M[i, basis.index(poly)] = mult
sage:      i += 1
\end{verbatim}
Et enfin, nous résolvons le système:
\begin{verbatim}
sage: B = vector (IntegerModRing(p ** (2 * k) - 1), solutionSide)
sage: basisLogs = M.solve_right(B)
\end{verbatim}

\section*{Conclusion}

\newpage
\thispagestyle{empty}
\bibliographystyle{abbrv}
\bibliography{mybib}

\end{document}
